// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 1bd92cedbbf431b3 "Sentinel AI", do not edit manually */
"use client";

import {
	Be,
	Fe,
	Go,
	Mn,
	Se,
	Vn,
	Yo,
	Z,
	be,
	ge,
	gi,
	jv,
	li,
	me,
	oa,
	qc,
	sn,
	td,
	vu,
	w,
} from "./chunks/chunk-STLWKYFF.js";
import { routes } from "./chunks/chunk-32AWGGTF.js";

// virtual:menu3-d
import { Fragment } from "react";
import { ContextProviders } from "unframer";

// /:https://framerusercontent.com/modules/aK7LlK314BzGn6BBue8M/VjNh0H1EyoAGX26w1Vdl/Menu3D.js
import { jsx as _jsx } from "react/jsx-runtime";
import * as React from "react";
import {
	useEffect,
	useLayoutEffect,
	useMemo as useMemo2,
	useRef,
	useState,
} from "react";
import { addPropertyControls, ControlType, RenderTarget } from "unframer";
var __unframerWindow = typeof window !== "undefined" ? window : void 0;
var PX_TO_WORLD = 1 / 100;
var Z_SEP = 0.01;
var MAX_PIXELS = 12e5;
var BLEND_WIDTH = 0.05;
var tmpN = new w();
function fontFamilyOf(font) {
	if (typeof font === "string") return font;
	return font?.family || font?.fontFamily || "Inter";
}
function fontWeightOf(font, fallback = 800) {
	if (typeof font === "object") {
		const w2 = font.fontWeight ?? font.weight;
		if (typeof w2 === "number") return w2;
		if (typeof w2 === "string") {
			const n = parseInt(w2, 10);
			if (!isNaN(n)) return n;
		}
	}
	return fallback;
}
function cssFont(font, weight, px) {
	const fam = fontFamilyOf(font);
	let q = fam;
	if (!/[",]/.test(fam) && /\s/.test(fam)) q = `"${fam}"`;
	const w2 = Math.round(weight) || 400;
	return `${w2} ${px}px ${q}`;
}
function fitDPR(w2, h, maxDPR) {
	const pr = __unframerWindow.devicePixelRatio || 1;
	const pxCap = Math.sqrt(MAX_PIXELS / Math.max(1, w2 * h));
	return Math.max(1, Math.min(pr, maxDPR, pxCap));
}
function makeGlyphTexture(ch, sizePx, color, family, weight, aniso) {
	const m = document.createElement("canvas").getContext("2d");
	m.font = `${weight} ${sizePx}px ${family}`;
	const pad = Math.ceil(Math.max(2, sizePx * 0.02));
	const innerW = Math.max(2, Math.ceil(m.measureText(ch).width));
	const w2 = innerW + pad * 2;
	const h = Math.ceil(sizePx * 1.6);
	const c = document.createElement("canvas");
	c.width = w2;
	c.height = h;
	const g = c.getContext("2d");
	g.clearRect(0, 0, w2, h);
	g.fillStyle = color;
	g.textAlign = "center";
	g.textBaseline = "middle";
	g.font = `${weight} ${sizePx}px ${family}`;
	g.imageSmoothingEnabled = true;
	g.imageSmoothingQuality = "high";
	g.fillText(ch, w2 / 2, h / 2 + sizePx * 0.06);
	const tex = new vu(c);
	tex.colorSpace = Se;
	tex.generateMipmaps = true;
	tex.minFilter = gi;
	tex.magFilter = me;
	tex.wrapS = Fe;
	tex.wrapT = Fe;
	tex.anisotropy = aniso;
	tex.needsUpdate = true;
	return {
		texture: tex,
		w: w2,
		h,
		pad,
		innerW,
	};
}
var vshader =
	/* glsl */
	`
  varying vec2 vUv;
  uniform float uBend; // 1/r
  void main(){
    vUv = uv;
    vec3 p = position;
    float k = uBend;
    if (abs(k) > 1e-6) {
      float r = 1.0 / k;
      float th = p.x * k;
      p.x = sin(th) * r;
      p.z += r - cos(th) * r;
    }
    gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
  }
`;
var fshader =
	/* glsl */
	`
  varying vec2 vUv;
  uniform sampler2D map;
  uniform float uOpacity;
  uniform float uMirror; // 0 = front, 1 = back (mirrored x)
  void main(){
    vec2 uv = mix(vUv, vec2(1.0 - vUv.x, vUv.y), uMirror);
    vec4 c = texture2D(map, uv);
    if (c.a < 0.01) discard;
    gl_FragColor = vec4(c.rgb, c.a * uOpacity);
  }
`;
function Menu3D(props) {
	const {
		nodes,
		textColor,
		font,
		fontSize,
		letterSpacingPx,
		gapPx,
		curveRadius,
		camZoom,
		camY,
		autoRotate,
		dragDamping,
		minBackOpacity,
		stopInEditor,
		maxDPR,
		aniso,
	} = props;
	const items = React.useMemo(
		() =>
			Array.isArray(nodes)
				? nodes.filter((n) => n && typeof n.label === "string")
				: [],
		[nodes],
	);
	const mountRef = useRef(null);
	const rendererRef = useRef(null);
	const cameraRef = useRef(null);
	const beltRef = useRef(null);
	const raycasterRef = useRef(new td());
	const mouseRef = useRef(new Z());
	const visRef = useRef(true);
	const shared = useRef({
		uBend: {
			value: 0,
		},
	});
	const autoRotateRef = useRef(autoRotate);
	const backMinRef = useRef(minBackOpacity);
	const stopEditorRef = useRef(stopInEditor);
	useEffect(() => void (autoRotateRef.current = autoRotate), [autoRotate]);
	useEffect(() => void (backMinRef.current = minBackOpacity), [minBackOpacity]);
	useEffect(() => void (stopEditorRef.current = stopInEditor), [stopInEditor]);
	const drag = useRef({
		down: false,
		lastX: 0,
		vel: 0,
		moved: false,
		t0: 0,
	});
	const hoveredWord = useRef(-1);
	const fontKey = useMemo2(
		() =>
			JSON.stringify({
				fam: fontFamilyOf(font),
				w: fontWeightOf(font),
				s: fontSize,
				c: textColor,
				ls: letterSpacingPx,
			}),
		[font, fontSize, textColor, letterSpacingPx],
	);
	const [fontReadyTick, setFontReadyTick] = useState(0);
	const glyphCacheRef = useRef(/* @__PURE__ */ new Map());
	const maxAnisoRef = useRef(1);
	const wordsRef = useRef([]);
	const hitTargetsRef = useRef([]);
	const hoverReq = useRef(null);
	useEffect(() => {
		for (const v of glyphCacheRef.current.values()) v.texture.dispose();
		glyphCacheRef.current.clear();
	}, [fontKey]);
	function getGlyphTexture(ch, sizePx, color, family, weight) {
		const key = `${ch}|${sizePx}|${color}|${family}|${weight}`;
		let rec = glyphCacheRef.current.get(key);
		if (!rec) {
			rec = makeGlyphTexture(
				ch,
				sizePx,
				color,
				family,
				weight,
				Math.min(Math.max(1, aniso), maxAnisoRef.current),
			);
			glyphCacheRef.current.set(key, rec);
		}
		return rec;
	}
	useLayoutEffect(() => {
		const mount = mountRef.current;
		if (!mount) return;
		const wantAA = (__unframerWindow.devicePixelRatio || 1) < 2;
		const renderer = new Go({
			antialias: wantAA,
			alpha: true,
			premultipliedAlpha: true,
			powerPreference: "high-performance",
		});
		rendererRef.current = renderer;
		renderer.shadowMap.enabled = false;
		renderer.outputColorSpace = Se;
		renderer.toneMapping = Vn;
		renderer.setClearColor(0, 0);
		renderer.domElement.style.imageRendering = "auto";
		maxAnisoRef.current = renderer.capabilities.getMaxAnisotropy();
		const dpr = fitDPR(
			mount.clientWidth,
			mount.clientHeight,
			Math.max(1, maxDPR),
		);
		renderer.setPixelRatio(dpr);
		renderer.setSize(mount.clientWidth, mount.clientHeight);
		mount.appendChild(renderer.domElement);
		const scene = new Yo();
		const camera = new be(28, mount.clientWidth / mount.clientHeight, 0.5, 1e3);
		camera.position.set(0, camY, 0);
		camera.lookAt(0, 0, 20);
		cameraRef.current = camera;
		const belt = new li();
		beltRef.current = belt;
		scene.add(belt);
		scene.add(new qc(16777215, 1));
		const io = new IntersectionObserver(
			([e]) => (visRef.current = e.isIntersecting),
			{
				threshold: 0.05,
			},
		);
		io.observe(mount);
		const onResize = () => {
			if (!mountRef.current || !rendererRef.current || !cameraRef.current)
				return;
			const w2 = mountRef.current.clientWidth;
			const h = mountRef.current.clientHeight;
			rendererRef.current.setPixelRatio(fitDPR(w2, h, Math.max(1, maxDPR)));
			rendererRef.current.setSize(w2, h);
			cameraRef.current.aspect = w2 / h;
			cameraRef.current.updateProjectionMatrix();
		};
		__unframerWindow.addEventListener("resize", onResize);
		const el = renderer.domElement;
		el.style.cursor = "grab";
		const onDown = (e) => {
			drag.current.down = true;
			drag.current.lastX = e.clientX;
			drag.current.vel = 0;
			drag.current.moved = false;
			drag.current.t0 = performance.now();
			el.setPointerCapture(e.pointerId);
			el.style.cursor = "grabbing";
		};
		const onMove = (e) => {
			if (!drag.current.down) {
				const rect = el.getBoundingClientRect();
				hoverReq.current = {
					x: e.clientX - rect.left,
					y: e.clientY - rect.top,
				};
				return;
			}
			const dx = e.clientX - drag.current.lastX;
			drag.current.lastX = e.clientX;
			const d = (dx / __unframerWindow.innerWidth) * Math.PI * 1.8;
			if (beltRef.current) beltRef.current.rotation.y += d;
			drag.current.vel = d / (1 / 60);
			if (Math.abs(dx) > 3) drag.current.moved = true;
		};
		const onUp = (e) => {
			drag.current.down = false;
			try {
				el.releasePointerCapture(e.pointerId);
			} catch {}
			el.style.cursor = "grab";
		};
		const onLeave = (e) => {
			if (drag.current.down) {
				try {
					el.releasePointerCapture(e.pointerId);
				} catch {}
				drag.current.down = false;
				el.style.cursor = "grab";
			}
		};
		el.addEventListener("pointerdown", onDown);
		el.addEventListener("pointermove", onMove);
		el.addEventListener("pointerup", onUp);
		el.addEventListener("pointercancel", onUp);
		el.addEventListener("pointerleave", onLeave);
		const onClick = (e) => {
			if (drag.current.moved && performance.now() - drag.current.t0 > 200)
				return;
			if (!cameraRef.current) return;
			const rect = el.getBoundingClientRect();
			mouseRef.current.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
			mouseRef.current.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
			raycasterRef.current.setFromCamera(mouseRef.current, cameraRef.current);
			const hit = raycasterRef.current.intersectObjects(
				hitTargetsRef.current,
				false,
			)[0];
			if (hit) {
				const url = hit.object.userData?.url;
				if (url) __unframerWindow.location.href = url;
			}
		};
		el.addEventListener("click", onClick);
		const baseN = new w(0, 0, 1);
		const toCam = new w();
		const wp = new w();
		const q = new Be();
		let lastT = performance.now();
		const tick = (now) => {
			const dt = Math.min(0.05, (now - lastT) / 1e3);
			lastT = now;
			if (!visRef.current) {
				requestAnimationFrame(tick);
				return;
			}
			const isEditor = RenderTarget.current() === RenderTarget.canvas;
			const stop = isEditor && stopEditorRef.current;
			const belt2 = beltRef.current;
			const cam = cameraRef.current;
			if (belt2 && cam) {
				if (!drag.current.down && !stop) {
					const auto = jv.degToRad(autoRotateRef.current);
					belt2.rotation.y += auto * dt;
					if (Math.abs(drag.current.vel) > 1e-4) {
						belt2.rotation.y += drag.current.vel * dt;
						drag.current.vel *= Math.pow(
							Math.max(1e-4, dragDamping || 0.06),
							dt,
						);
					}
				}
				if (hoverReq.current) {
					const { x, y } = hoverReq.current;
					hoverReq.current = null;
					const rect = renderer.domElement.getBoundingClientRect();
					mouseRef.current.set(
						(x / rect.width) * 2 - 1,
						-(y / rect.height) * 2 + 1,
					);
					raycasterRef.current.setFromCamera(mouseRef.current, cam);
					const hit = raycasterRef.current.intersectObjects(
						hitTargetsRef.current,
						false,
					)[0];
					hoveredWord.current = hit
						? (hit.object.userData.wordIndex ?? -1)
						: -1;
					renderer.domElement.style.cursor =
						hoveredWord.current >= 0 ? "pointer" : "grab";
				}
				const words = wordsRef.current;
				for (let wi = 0; wi < words.length; wi++) {
					const W = words[wi];
					const mid = W.front[(W.front.length - 1) >> 1]?.mesh;
					if (!mid) continue;
					mid.getWorldPosition(wp);
					toCam.copy(cam.position).sub(wp).normalize();
					mid.getWorldQuaternion(q);
					tmpN.set(0, 0, 1).applyQuaternion(q);
					const dot = tmpN.dot(toCam);
					const target = jv.smoothstep(-dot, -BLEND_WIDTH, BLEND_WIDTH);
					W.blend += (target - W.blend) * Math.min(1, dt * 18);
					const dfWord = Math.max(0, tmpN.dot(toCam));
					const baseA = backMinRef.current + (1 - backMinRef.current) * dfWord;
					const hoverMul = hoveredWord.current === wi ? 0.6 : 1;
					const aFront = (1 - W.blend) * baseA * hoverMul;
					const aBack = W.blend * baseA * hoverMul;
					for (const L of W.front) L.mat.uniforms.uOpacity.value = aFront;
					for (const L of W.back) L.mat.uniforms.uOpacity.value = aBack;
				}
			}
			renderer.render(scene, cam);
			requestAnimationFrame(tick);
		};
		requestAnimationFrame(tick);
		return () => {
			__unframerWindow.removeEventListener("resize", onResize);
			el.removeEventListener("pointerdown", onDown);
			el.removeEventListener("pointermove", onMove);
			el.removeEventListener("pointerup", onUp);
			el.removeEventListener("pointercancel", onUp);
			el.removeEventListener("pointerleave", onLeave);
			io.disconnect();
			if (beltRef.current) {
				beltRef.current.traverse((obj) => {
					const mesh = obj;
					if (mesh.isMesh) {
						mesh.geometry?.dispose?.();
						const m = mesh.material;
						if (Array.isArray(m)) m.forEach((mm) => mm?.dispose?.());
						else m?.dispose?.();
					}
				});
			}
			renderer.dispose();
			if (mount.contains(el)) mount.removeChild(el);
		};
	}, []);
	useEffect(() => {
		const cam = cameraRef.current;
		if (!cam) return;
		const baseZ = 35;
		const z = baseZ / Math.max(0.05, camZoom);
		cam.position.z = z;
		cam.updateProjectionMatrix();
	}, [camZoom]);
	useEffect(() => {
		const cam = cameraRef.current;
		if (!cam) return;
		cam.position.y = camY;
		cam.lookAt(0, 0, 0);
	}, [camY]);
	useEffect(() => {
		const fam = fontFamilyOf(font);
		const weight = fontWeightOf(font);
		const css = cssFont(font, weight, fontSize);
		const fs = document.fonts;
		let cancelled = false;
		try {
			fs?.load?.(css, "BESbswy");
		} catch {}
		const cssCheck = css.replace(/\b\d+px\b/, "16px");
		const tick = () => setFontReadyTick((t) => t + 1);
		const onDone = () => {
			if (!cancelled) tick();
		};
		fs?.addEventListener?.("loadingdone", onDone);
		const delays = [120, 300, 600, 1e3, 1500];
		const timers = delays.map((ms) =>
			__unframerWindow.setTimeout(() => {
				if (cancelled) return;
				try {
					if (fs?.check?.(cssCheck, " ")) tick();
				} catch {}
			}, ms),
		);
		return () => {
			cancelled = true;
			fs?.removeEventListener?.("loadingdone", onDone);
			timers.forEach(clearTimeout);
		};
	}, [fontKey]);
	useEffect(() => {
		if (!rendererRef.current || !beltRef.current) return;
		const belt = beltRef.current;
		while (belt.children.length) {
			const ch = belt.children.pop();
			if (!ch) break;
			ch.traverse?.((o) => {
				if (o.isMesh) {
					o.geometry?.dispose?.();
					const m = o.material;
					if (Array.isArray(m)) m.forEach((mm) => mm?.dispose?.());
					else m?.dispose?.();
				}
			});
		}
		wordsRef.current.length = 0;
		hitTargetsRef.current.length = 0;
		const family = fontFamilyOf(font);
		const weight = fontWeightOf(font);
		const lsWorld = letterSpacingPx * PX_TO_WORLD;
		const gapWorld = gapPx * PX_TO_WORLD;
		const r = Math.max(0, curveRadius);
		shared.current.uBend.value = r > 1e-4 ? 1 / r : 0;
		const makeMat = (tex, mirror, poly) =>
			new sn({
				uniforms: {
					map: {
						value: tex,
					},
					uOpacity: {
						value: 1,
					},
					uMirror: {
						value: mirror,
					},
					uBend: shared.current.uBend,
				},
				vertexShader: vshader,
				fragmentShader: fshader,
				transparent: true,
				depthWrite: false,
				depthTest: true,
				side: Mn,
				alphaTest: 0.01,
				polygonOffset: true,
				polygonOffsetFactor: poly,
				polygonOffsetUnits: poly,
			});
		for (let wi = 0; wi < items.length; wi++) {
			const it = items[wi];
			const group = new li();
			belt.add(group);
			const front = [];
			const back = [];
			for (const ch of [...(it.label || "")]) {
				const {
					texture,
					w: tw,
					h: th,
					pad,
					innerW,
				} = getGlyphTexture(ch, fontSize, textColor, family, weight);
				const W = innerW * PX_TO_WORLD;
				const H = th * PX_TO_WORLD;
				const u0 = pad / tw;
				const u1 = 1 - pad / tw;
				const makeCroppedPlane = () => {
					const geo = new oa(W, H, 1, 1);
					const uv = geo.getAttribute("uv");
					for (let i = 0; i < uv.count; i++) {
						const u = uv.getX(i);
						const v = uv.getY(i);
						uv.setXY(i, u0 + (u1 - u0) * u, v);
					}
					uv.needsUpdate = true;
					return geo;
				};
				const geoF = makeCroppedPlane();
				const geoB = makeCroppedPlane();
				const matF = makeMat(texture, 0, 1);
				const matB = makeMat(texture, 1, -1);
				const mF = new ge(geoF, matF);
				const mB = new ge(geoB, matB);
				mF.frustumCulled = true;
				mB.frustumCulled = true;
				mF.userData = {
					wordIndex: wi,
					url: it.link || "",
				};
				mB.userData = {
					wordIndex: wi,
					url: it.link || "",
				};
				front.push({
					mesh: mF,
					mat: matF,
					W,
					H,
					offset: 0,
				});
				back.push({
					mesh: mB,
					mat: matB,
					W,
					H,
					offset: 0,
				});
				group.add(mF);
				group.add(mB);
			}
			wordsRef.current.push({
				group,
				front,
				back,
				width: 0,
				href: it.link || "",
				blend: 0,
			});
		}
		function measureLayer(layer) {
			let x = 0;
			for (let i = 0; i < layer.length; i++) {
				const L = layer[i];
				L.offset = x + L.W / 2;
				x += L.W;
				if (i < layer.length - 1) x += lsWorld;
			}
			return x;
		}
		function layout() {
			const bend = shared.current.uBend.value;
			const place = (lx) => {
				if (Math.abs(bend) < 1e-6)
					return {
						pos: new w(lx, 0, 0),
						rotY: 0,
					};
				const rad = 1 / bend;
				const th = lx / rad;
				return {
					pos: new w(Math.sin(th) * rad, 0, Math.cos(th) * rad),
					rotY: th,
				};
			};
			for (const w2 of wordsRef.current) {
				const wf = measureLayer(w2.front);
				measureLayer(w2.back);
				w2.width = wf;
			}
			const total =
				wordsRef.current.reduce((s2, w2) => s2 + w2.width, 0) +
				(wordsRef.current.length - 1) * gapWorld;
			let s = -total / 2;
			for (let wi = 0; wi < wordsRef.current.length; wi++) {
				const w2 = wordsRef.current[wi];
				const wordMid = s + w2.width / 2;
				for (const L of w2.front) {
					const P = place(wordMid + (L.offset - w2.width / 2));
					L.mesh.position.copy(P.pos);
					L.mesh.rotation.set(0, P.rotY, 0);
					L.mesh.position.z += Z_SEP;
				}
				for (const L of w2.back) {
					const mirrored = -(L.offset - w2.width / 2);
					const P = place(wordMid + mirrored);
					L.mesh.position.copy(P.pos);
					L.mesh.rotation.set(0, P.rotY, 0);
					L.mesh.position.z -= Z_SEP;
				}
				s += w2.width + (wi < wordsRef.current.length - 1 ? gapWorld : 0);
			}
		}
		layout();
		hitTargetsRef.current.length = 0;
		for (const w2 of wordsRef.current) {
			for (const L of w2.front) hitTargetsRef.current.push(L.mesh);
			for (const L of w2.back) hitTargetsRef.current.push(L.mesh);
		}
	}, [
		items,
		fontKey,
		curveRadius,
		gapPx,
		letterSpacingPx,
		aniso,
		fontReadyTick,
	]);
	return (
		<div
			ref={mountRef}
			style={{
				width: "100%",
				height: "100%",
			}}
		/>
	);
}
addPropertyControls(Menu3D, {
	nodes: {
		type: ControlType.Array,
		title: "Nodes",
		defaultValue: [
			{
				label: "Home",
				link: "",
			},
			{
				label: "About",
				link: "",
			},
			{
				label: "Work",
				link: "",
			},
			{
				label: "Awards",
				link: "",
			},
			{
				label: "Contact",
				link: "",
			},
		],
		propertyControl: {
			type: ControlType.Object,
			controls: {
				label: {
					type: ControlType.String,
					title: "Title",
					defaultValue: "Item",
				},
				link: {
					type: ControlType.Link,
					title: "Link",
				},
			},
		},
	},
	textColor: {
		type: ControlType.Color,
		title: "Text",
		defaultValue: "#ffffff",
	},
	font: {
		type: ControlType.Font,
		title: "Font",
		defaultValue: {
			fontFamily: "Inter",
			fontWeight: 800,
		},
	},
	fontSize: {
		type: ControlType.Number,
		title: "Font px",
		defaultValue: 210,
		min: 24,
		max: 360,
		unit: "px",
		step: 1,
		displayStepper: true,
	},
	letterSpacingPx: {
		type: ControlType.Number,
		title: "Letter px",
		defaultValue: -10,
		min: -40,
		max: 60,
		step: 1,
		unit: "px",
	},
	gapPx: {
		type: ControlType.Number,
		title: "Word Gap px",
		defaultValue: 60,
		min: 0,
		max: 400,
		step: 1,
		unit: "px",
	},
	curveRadius: {
		type: ControlType.Number,
		title: "Radius",
		defaultValue: 10,
		min: 0.5,
		max: 30,
		step: 0.05,
	},
	camZoom: {
		type: ControlType.Number,
		title: "Cam Zoom",
		defaultValue: 0.2,
		min: 0.05,
		max: 3,
		step: 0.01,
	},
	camY: {
		type: ControlType.Number,
		title: "Cam Y",
		defaultValue: -2,
		min: -10,
		max: 10,
		step: 0.1,
	},
	autoRotate: {
		type: ControlType.Number,
		title: "Auto \xB0/s",
		defaultValue: 8,
		min: -30,
		max: 30,
		step: 0.1,
	},
	dragDamping: {
		type: ControlType.Number,
		title: "Drag Damping",
		defaultValue: 0.06,
		min: 0.01,
		max: 0.3,
		step: 0.01,
	},
	minBackOpacity: {
		type: ControlType.Number,
		title: "Back Min \u03B1",
		defaultValue: 0.18,
		min: 0,
		max: 1,
		step: 0.01,
	},
	stopInEditor: {
		type: ControlType.Boolean,
		title: "Stop Animation in Editor",
		defaultValue: false,
		enabledTitle: "On",
		disabledTitle: "Off",
	},
	maxDPR: {
		type: ControlType.Number,
		title: "Max DPR",
		defaultValue: 1,
		min: 1,
		max: 3,
		step: 0.5,
	},
	aniso: {
		type: ControlType.Number,
		title: "Anisotropy",
		defaultValue: 1,
		min: 1,
		max: 16,
		step: 1,
	},
});
Menu3D.defaultProps = {
	width: 960,
	height: 420,
	// Provide a stable default nodes list
	nodes: [
		{
			label: "Home",
			link: "",
		},
		{
			label: "About",
			link: "",
		},
		{
			label: "Work",
			link: "",
		},
		{
			label: "Awards",
			link: "",
		},
		{
			label: "Contact",
			link: "",
		},
	],
};

// virtual:menu3-d
import { WithFramerBreakpoints } from "unframer";
import { jsx } from "react/jsx-runtime";
var locales = [];
var defaultResponsiveVariants = {};
function ComponentWithRoot({ locale, ...rest }) {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"1bd92cedbbf431b3411a7ddd12ea507e929f85a97d28da8179a9646480dcde76"
			}
			locale={locale}
			locales={locales}
		>
			<Menu3D {...rest} />
		</ContextProviders>
	);
}
ComponentWithRoot.Responsive = ({ locale = "", ...rest }) => {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"1bd92cedbbf431b3411a7ddd12ea507e929f85a97d28da8179a9646480dcde76"
			}
			locale={locale}
			locales={locales}
		>
			<WithFramerBreakpoints
				Component={Menu3D}
				variants={defaultResponsiveVariants}
				{...rest}
			/>
		</ContextProviders>
	);
};
Object.assign(ComponentWithRoot, Menu3D);
var menu3_d_default = ComponentWithRoot;
export { menu3_d_default as default };
