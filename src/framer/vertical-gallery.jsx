// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 1bd92cedbbf431b3 "Sentinel AI", do not edit manually */
"use client";

/**
 * @typedef Locale
 * string
 */

/**
 * @typedef {{
 * children?: React.ReactNode
 * locale?: Locale
 * style?: React.CSSProperties
 * className?: string
 * id?: string
 * ref?: any
 * width?: any
 * height?: any
 * layoutId?: string
 * images?: string[] // Images
 * videos?: string[] // Videos
 * autoplayVideo?: boolean // Autoplay Video
 * cards?: number // Cards
 * mix?: 'Images first' | 'Videos first' | 'Interleave' // Mix
 * gapRem?: number // Gap rem
 * cardWVw?: number // Card W vw
 * cardHVh?: number // Card H vh
 * openWVw?: number // Open W vw
 * radiusPx?: number // Radius px
 * background?: string // Background
}} Props

 */
import { routes } from "./chunks/chunk-32AWGGTF.js";

// virtual:vertical-gallery
import { Fragment } from "react";
import { ContextProviders } from "unframer";

// /:https://framerusercontent.com/modules/v0JB9wMhZxQrA5j1xqKK/lf79Jse0qW5Q3KcBRvyI/Vertical_Gallery.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import * as React from "react";
import { addPropertyControls, ControlType, RenderTarget } from "unframer";
var __unframerWindow = typeof window !== "undefined" ? window : void 0;
function VerticalGallery(props) {
	const {
		images = [],
		videos = [],
		itemsCount = 12,
		mixMode = "images-first",
		gapRem = 0.2,
		cardWidthVw = 3,
		cardHeightVh = 18,
		borderRadiusPx = 100,
		openWidthVw = 20,
		bg = "#141414",
		autoplayVideo = true,
	} = props;
	const isRuntimeAutoplay = RenderTarget.current() !== RenderTarget.canvas;
	const shouldNativeAutoplay = isRuntimeAutoplay && autoplayVideo;
	const imgs = (images || []).filter(Boolean).map((src) => ({
		type: "image",
		src,
	}));
	const vids = (videos || []).filter(Boolean).map((src) => ({
		type: "video",
		src,
	}));
	const media = React.useMemo(() => {
		const out = [];
		if (mixMode === "images-first") out.push(...imgs, ...vids);
		else if (mixMode === "videos-first") out.push(...vids, ...imgs);
		else {
			const max = Math.max(imgs.length, vids.length);
			for (let i = 0; i < max; i++) {
				if (i < imgs.length) out.push(imgs[i]);
				if (i < vids.length) out.push(vids[i]);
			}
		}
		return out.slice(0, Math.max(1, itemsCount));
	}, [imgs, vids, mixMode, itemsCount]);
	const [isLoading, setIsLoading] = React.useState(true);
	const preloadMedia = React.useCallback((mediaItems) => {
		const promises = mediaItems.map((item) => {
			return new Promise((resolve, reject) => {
				if (item.type === "image") {
					const img = new Image();
					img.onload = () => resolve();
					img.onerror = reject;
					img.src = item.src;
				} else {
					const vid = document.createElement("video");
					vid.preload = "metadata";
					vid.onloadedmetadata = () => resolve();
					vid.onerror = reject;
					vid.src = item.src;
				}
			});
		});
		return Promise.allSettled(promises).then(() => setIsLoading(false));
	}, []);
	React.useEffect(() => {
		if (media.length === 0) {
			setIsLoading(false);
			return;
		}
		preloadMedia(media);
	}, [media, preloadMedia]);
	const containerRef = React.useRef(null);
	const itemRefs = React.useRef([]);
	const videoRefs = React.useRef([]);
	const [openIndex, setOpenIndex] = React.useState(-1);
	const [hoverIndex, setHoverIndex] = React.useState(-1);
	const [isHovering, setIsHovering] = React.useState(false);
	const [inViewport, setInViewport] = React.useState(true);
	const padLeftRef = React.useRef(0);
	const firstCenterRef = React.useRef(0);
	const stepRef = React.useRef(0);
	const epsBaseRef = React.useRef(12);
	const prevXRef = React.useRef(null);
	const prevTRef = React.useRef(0);
	const metric = React.useCallback(() => {
		const container = containerRef.current;
		const first = itemRefs.current[0];
		if (!container || !first) return;
		const cs = getComputedStyle(container);
		const padLeft = parseFloat(cs.paddingLeft) || 0;
		const w = first.offsetWidth || 0;
		const gap = parseFloat(cs.gap) || 0;
		padLeftRef.current = padLeft;
		stepRef.current = w + gap;
		firstCenterRef.current = (first.offsetLeft || 0) + w / 2;
		epsBaseRef.current = Math.max(10, stepRef.current * 0.08);
	}, []);
	React.useEffect(() => {
		const id = requestAnimationFrame(metric);
		const onResize = () => metric();
		__unframerWindow.addEventListener("resize", onResize);
		return () => {
			cancelAnimationFrame(id);
			__unframerWindow.removeEventListener("resize", onResize);
		};
	}, [metric, media.length, gapRem, cardWidthVw, cardHeightVh]);
	React.useEffect(() => {
		requestAnimationFrame(metric);
	}, [isHovering, metric]);
	React.useEffect(() => {
		const el = containerRef.current;
		if (!el) return;
		const observer = new IntersectionObserver(
			(entries) => {
				const entry = entries[0];
				setInViewport(entry.isIntersecting);
			},
			{
				threshold: 0.1,
			},
		);
		observer.observe(el);
		return () => {
			observer.disconnect();
		};
	}, [media.length]);
	const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
	const indexFromX = (x) =>
		clamp(
			Math.round((x - firstCenterRef.current) / stepRef.current),
			0,
			media.length - 1,
		);
	const centerFor = (i) => firstCenterRef.current + i * stepRef.current;
	const safePlay = React.useCallback((v) => {
		if (!v) return;
		const p = v.play();
		if (p && typeof p.catch === "function") {
			p.catch(() => {});
		}
	}, []);
	const pauseToFirstFrame = React.useCallback((v) => {
		if (!v) return;
		v.pause();
		if (v.readyState >= 2) {
			try {
				v.currentTime = 0;
			} catch {}
		} else {
			const onMeta = () => {
				try {
					v.currentTime = 0;
				} catch {}
				v.removeEventListener("loadedmetadata", onMeta);
			};
			v.addEventListener("loadedmetadata", onMeta);
		}
	}, []);
	React.useEffect(() => {
		if (!inViewport) {
			videoRefs.current.forEach((v) => {
				if (!v) return;
				v.pause();
			});
			return;
		}
		if (autoplayVideo && isRuntimeAutoplay) {
			videoRefs.current.forEach((v) => safePlay(v));
		} else {
			videoRefs.current.forEach((v) => pauseToFirstFrame(v));
		}
	}, [
		autoplayVideo,
		isRuntimeAutoplay,
		inViewport,
		media.length,
		safePlay,
		pauseToFirstFrame,
	]);
	const prevHoverRef = React.useRef(-1);
	React.useEffect(() => {
		if (autoplayVideo) return;
		if (openIndex !== -1) return;
		const prev = prevHoverRef.current;
		if (prev !== -1 && prev !== hoverIndex && media[prev]?.type === "video") {
			pauseToFirstFrame(videoRefs.current[prev]);
		}
		if (hoverIndex >= 0 && media[hoverIndex]?.type === "video") {
			safePlay(videoRefs.current[hoverIndex]);
		}
		prevHoverRef.current = hoverIndex;
	}, [
		hoverIndex,
		autoplayVideo,
		openIndex,
		media,
		pauseToFirstFrame,
		safePlay,
	]);
	React.useEffect(() => {
		if (openIndex === -1) return;
		if (media[openIndex]?.type === "video") {
			safePlay(videoRefs.current[openIndex]);
		}
	}, [openIndex, media, safePlay]);
	const centerItem = React.useCallback((idx) => {
		const container = containerRef.current;
		const el = itemRefs.current[idx];
		if (!container || !el) return;
		const wrap = container.getBoundingClientRect();
		const it = el.getBoundingClientRect();
		const centerX = wrap.left + wrap.width / 2;
		const delta = centerX - (it.left + it.width / 2);
		const maxShift = wrap.width * 0.35;
		const clamped = Math.max(-maxShift, Math.min(maxShift, delta));
		container.style.setProperty("--shift", clamped.toFixed(1) + "px");
	}, []);
	React.useLayoutEffect(() => {
		if (openIndex >= 0) {
			requestAnimationFrame(() => centerItem(openIndex));
		} else {
			containerRef.current?.style.setProperty("--shift", "0px");
		}
	}, [openIndex, centerItem, openWidthVw]);
	const onPointerEnter = () => {
		if (openIndex !== -1) return;
		setIsHovering(true);
	};
	const onPointerLeave = () => {
		if (openIndex !== -1) return;
		if (
			!autoplayVideo &&
			hoverIndex >= 0 &&
			media[hoverIndex]?.type === "video"
		) {
			pauseToFirstFrame(videoRefs.current[hoverIndex]);
		}
		setIsHovering(false);
		setHoverIndex(-1);
		prevXRef.current = null;
		prevTRef.current = 0;
	};
	const onPointerMove = (e) => {
		if (openIndex !== -1) return;
		if (!isHovering) setIsHovering(true);
		const rect = containerRef.current?.getBoundingClientRect();
		if (!rect) return;
		const x = e.clientX - rect.left - (padLeftRef.current || 0);
		const approxPad = padLeftRef.current || 48;
		const innerWidth = rect.width - 2 * approxPad;
		const buffer = Math.max(stepRef.current, 48);
		if (x < -buffer || x > innerWidth + buffer) {
			onPointerLeave();
			return;
		}
		const idxRaw = indexFromX(x);
		let idx = idxRaw;
		if (hoverIndex >= 0) {
			const c = centerFor(hoverIndex);
			const movingRight =
				prevXRef.current == null ? true : x > prevXRef.current;
			const now = performance.now();
			const dt = Math.max(1, now - (prevTRef.current || now));
			const v = Math.abs((x - (prevXRef.current ?? x)) / dt);
			const k = clamp(1 - v * 0.8, 0.4, 1);
			const eps = (epsBaseRef.current || 12) * k;
			if (movingRight && x < c + eps) idx = hoverIndex;
			if (!movingRight && x > c - eps) idx = hoverIndex;
			prevTRef.current = now;
		}
		prevXRef.current = x;
		if (idx !== hoverIndex) setHoverIndex(idx);
	};
	const onContainerClick = (e) => {
		const target = e.target;
		const el = target.closest(".item");
		let idx = -1;
		if (el) idx = itemRefs.current.indexOf(el);
		else if (hoverIndex >= 0) idx = hoverIndex;
		if (idx < 0) return;
		setOpenIndex((prev) => (prev === idx ? -1 : idx));
	};
	React.useEffect(() => {
		if (openIndex === -1) return;
		const onDocDown = (ev) => {
			const openedEl = itemRefs.current[openIndex];
			const path = ev.composedPath();
			const onAnyItem = path.some((n) => n?.classList?.contains("item"));
			const insideOpened = openedEl ? path.includes(openedEl) : false;
			if (!insideOpened && !onAnyItem) setOpenIndex(-1);
		};
		document.addEventListener("mousedown", onDocDown, true);
		return () => document.removeEventListener("mousedown", onDocDown, true);
	}, [openIndex]);
	React.useEffect(() => {
		const resetHover = () => {
			if (openIndex !== -1) return;
			if (
				!autoplayVideo &&
				hoverIndex >= 0 &&
				media[hoverIndex]?.type === "video"
			) {
				pauseToFirstFrame(videoRefs.current[hoverIndex]);
			}
			setIsHovering(false);
			setHoverIndex(-1);
			prevXRef.current = null;
			prevTRef.current = 0;
		};
		const onWindowMouseOut = (e) => {
			if (!e.relatedTarget) resetHover();
		};
		const onBlur = () => resetHover();
		const onVis = () => {
			if (document.visibilityState !== "visible") resetHover();
		};
		__unframerWindow.addEventListener("mouseout", onWindowMouseOut);
		__unframerWindow.addEventListener("blur", onBlur);
		document.addEventListener("visibilitychange", onVis);
		return () => {
			__unframerWindow.removeEventListener("mouseout", onWindowMouseOut);
			__unframerWindow.removeEventListener("blur", onBlur);
			document.removeEventListener("visibilitychange", onVis);
		};
	}, [openIndex, hoverIndex, media, autoplayVideo, pauseToFirstFrame]);
	function getItemClass(i) {
		if (openIndex === i) return "item is-open";
		if (openIndex !== -1) return "item";
		if (!isHovering || hoverIndex < 0) return "item";
		const d = i - hoverIndex;
		if (d === 0) return "item is-hover-main";
		if (d === 1) return "item is-right-1";
		if (d === 2) return "item is-right-2";
		if (d === 3) return "item is-right-3";
		if (d === 4) return "item is-right-4";
		if (d === -1) return "item is-left-1";
		if (d === -2) return "item is-left-2";
		if (d === -3) return "item is-left-3";
		if (d === -4) return "item is-left-4";
		return "item";
	}
	if (isLoading) {
		return (
			<div
				className={"wrapper"}
				style={{
					background: bg,
				}}
			>
				<div className={"preloader"}>
					<span>{"Loading..."}</span>
				</div>
				<style>{`
                    .preloader {
                        position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
                        background: transparent; z-index: 1000;
                    }
                    .preloader span {
                        font-size: 14.4px; font-weight: 500; color: white; font-family: system-ui, -apple-system, sans-serif;
                        transform: rotate(4deg);
                    }
                `}</style>
			</div>
		);
	}
	return (
		<div
			className={"wrapper"}
			style={{
				background: bg,
			}}
		>
			<div
				className={`items${isHovering ? " hovering" : ""}${openIndex !== -1 ? " is-open" : ""}`}
				ref={containerRef}
				tabIndex={0}
				onPointerEnter={onPointerEnter}
				onPointerMove={onPointerMove}
				onPointerLeave={onPointerLeave}
				onClick={onContainerClick}
				onKeyDown={(e) => {
					if (e.key === "Escape" && openIndex !== -1) {
						e.preventDefault();
						setOpenIndex(-1);
					}
				}}
				style={{
					"--gap-base": `${gapRem}rem`,
					"--index": "calc(1vw + 1vh)",
					"--transition": "cubic-bezier(.1,.7,0,1)",
					["--cardW"]: `${cardWidthVw}`,
					["--cardH"]: `${cardHeightVh}`,
					["--openW"]: `${openWidthVw}`,
					["--radius"]: `${borderRadiusPx}px`,
				}}
			>
				{media.map((m, i) => {
					const isOpen = openIndex === i;
					return (
						<div
							className={getItemClass(i)}
							ref={(el) => {
								if (el) itemRefs.current[i] = el;
							}}
							data-idx={i}
							tabIndex={0}
							aria-label={`Card ${i + 1}`}
							style={
								isOpen
									? {
											width: `${openWidthVw}vw`,
										}
									: void 0
							}
						>
							{m.type === "image" ? (
								<img
									src={m.src}
									alt={""}
									draggable={false}
									loading={"lazy"}
									decoding={"async"}
								/>
							) : (
								<video
									ref={(el) => {
										videoRefs.current[i] = el;
									}}
									src={m.src}
									muted={true}
									loop={true}
									playsInline={true}
									autoPlay={shouldNativeAutoplay}
									preload={"metadata"}
									onLoadedMetadata={(e) => {
										if (!autoplayVideo) {
											const v = e.currentTarget;
											v.pause();
											try {
												v.currentTime = 0;
											} catch {}
										}
									}}
								/>
							)}
						</div>
					);
				})}
			</div>
			<style>{`
    * { box-sizing: border-box; }

    .wrapper {
        width: 100%; height: 100%;
        display: flex; align-items: center; justify-content: center;
        overflow: visible; position: relative;
    }

    .items {
        display: flex;
        gap: var(--gap, var(--gap-base));
        perspective: calc(var(--index) * 35);
        perspective-origin: 50% 50%;
        transform: translateX(var(--shift, 0px));
        transform-style: preserve-3d;
        will-change: transform;
        overflow: visible;
        transition: transform 0.6s var(--transition);
        padding-inline: clamp(1rem, 5vw, 3rem);
        margin-inline: calc(clamp(1rem, 5vw, 3rem) * -1);
        outline: none;
    }

    .items.hovering { --gap: calc(var(--gap-base) / 2); }

    .item {
        position: relative;
        width: clamp(60px, calc(var(--index) * var(--cardW)), 25vw);
        height: clamp(120px, calc(var(--index) * var(--cardH)), 40vh);
        background: #222;
        cursor: pointer;
        transition: transform 1.25s var(--transition), width 0.6s var(--transition), filter 0.35s ease;
        transform: translateZ(0) rotateY(0deg);
        transform-style: preserve-3d;
        backface-visibility: hidden;
        will-change: transform, width, filter;
        outline: none;
        border-radius: var(--radius);
        flex: 0 0 auto;
        user-select: none;
        overflow: hidden;
    }

    .item img, .item video {
        position: absolute; inset: 0;
        width: 100%; height: 100%;
        object-fit: cover; display: block;
        pointer-events: none;
    }

    .item.is-hover-main { transform: translateZ(calc(var(--index) * 10)); z-index: 10; }
    .item.is-right-1 { transform: translateZ(calc(var(--index) * 8.5)) rotateY(35deg); z-index: 9; }
    .item.is-right-2 { transform: translateZ(calc(var(--index) * 5.6)) rotateY(40deg); z-index: 8; }
    .item.is-right-3 { transform: translateZ(calc(var(--index) * 2.5)) rotateY(30deg); z-index: 7; }
    .item.is-right-4 { transform: translateZ(calc(var(--index) * 0.6)) rotateY(15deg); z-index: 6; }
    .item.is-left-1  { transform: translateZ(calc(var(--index) * 8.5)) rotateY(-35deg); z-index: 9; }
    .item.is-left-2  { transform: translateZ(calc(var(--index) * 5.6)) rotateY(-40deg); z-index: 8; }
    .item.is-left-3  { transform: translateZ(calc(var(--index) * 2.5)) rotateY(-30deg); z-index: 7; }
    .item.is-left-4  { transform: translateZ(calc(var(--index) * 0.6)) rotateY(-15deg); z-index: 6; }

    .items.is-open .item {
        transition: transform 0.8s var(--transition), width 0.6s var(--transition), filter 0.35s ease;
    }

    .item.is-open {
        z-index: 100;
        transform: translateZ(calc(var(--index) * 10));
        width: clamp(200px, calc(var(--openW) * 1vw), 90vw) !important;
    }

    .items.is-open .item:not(.is-open) { filter: blur(8px) saturate(0.95) brightness(0.9); }

    @media (max-width: 1024px) {
        .item { height: clamp(140px, calc(var(--index) * var(--cardH) * 1.8), min(40vh, 50vw)); }
    }
    @media (max-width: 768px) {
        .item { height: clamp(160px, calc(var(--index) * var(--cardH) * 2.5), min(45vh, 65vw)); }
    }
    @media (max-width: 480px) {
        .item { height: clamp(180px, calc(var(--index) * var(--cardH) * 3), min(50vh, 80vw)); }
        .items { padding-inline: 1rem; margin-inline: -1rem; }
    }
`}</style>
		</div>
	);
}
addPropertyControls(VerticalGallery, {
	images: {
		type: ControlType.Array,
		title: "Images",
		control: {
			type: ControlType.Image,
		},
		defaultValue: ["", "", "", ""],
	},
	videos: {
		type: ControlType.Array,
		title: "Videos",
		control: {
			type: ControlType.File,
			allowedFileTypes: ["mp4", "webm", "mov", "m4v"],
		},
		defaultValue: [],
	},
	autoplayVideo: {
		type: ControlType.Boolean,
		title: "Autoplay Video",
		defaultValue: true,
	},
	itemsCount: {
		type: ControlType.Number,
		title: "Cards",
		min: 1,
		max: 32,
		step: 1,
		defaultValue: 12,
		displayStepper: true,
	},
	mixMode: {
		type: ControlType.Enum,
		title: "Mix",
		options: ["images-first", "videos-first", "interleave"],
		optionTitles: ["Images first", "Videos first", "Interleave"],
		defaultValue: "images-first",
	},
	gapRem: {
		type: ControlType.Number,
		title: "Gap rem",
		min: 0,
		max: 2,
		step: 0.05,
		defaultValue: 0.2,
	},
	cardWidthVw: {
		type: ControlType.Number,
		title: "Card W vw",
		min: 0.1,
		max: 12,
		step: 0.1,
		defaultValue: 3,
	},
	cardHeightVh: {
		type: ControlType.Number,
		title: "Card H vh",
		min: 6,
		max: 40,
		step: 0.5,
		defaultValue: 18,
	},
	openWidthVw: {
		type: ControlType.Number,
		title: "Open W vw",
		min: 1,
		max: 60,
		step: 1,
		defaultValue: 20,
	},
	borderRadiusPx: {
		type: ControlType.Number,
		title: "Radius px",
		min: 0,
		max: 200,
		step: 1,
		defaultValue: 100,
	},
	bg: {
		type: ControlType.Color,
		title: "Background",
		defaultValue: "#141414",
	},
});

// virtual:vertical-gallery
import { WithFramerBreakpoints } from "unframer";
import { jsx } from "react/jsx-runtime";
var locales = [];
var defaultResponsiveVariants = {};
/** @type {function(Props): any} */
function ComponentWithRoot({ locale, ...rest }) {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"1bd92cedbbf431b3411a7ddd12ea507e929f85a97d28da8179a9646480dcde76"
			}
			locale={locale}
			locales={locales}
		>
			<VerticalGallery {...rest} />
		</ContextProviders>
	);
}
/**
 * @type {import("unframer").UnframerBreakpoint}
 * Represents a responsive breakpoint for unframer.
 */

/**
 * @typedef VariantsMap
 * Partial record of UnframerBreakpoint to Props.variant, with a mandatory 'base' key.
 * { [key in UnframerBreakpoint]?: Props['variant'] } & { base: Props['variant'] }
 */

/**
 * Renders VerticalGalleryFramerComponent for all breakpoints with a variants map. Variant prop is inferred per breakpoint.
 * @function
 * @param {Omit<Props, 'variant'> & {variants?: VariantsMap}} props
 * @returns {any}
 */
ComponentWithRoot.Responsive = ({ locale = "", ...rest }) => {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"1bd92cedbbf431b3411a7ddd12ea507e929f85a97d28da8179a9646480dcde76"
			}
			locale={locale}
			locales={locales}
		>
			<WithFramerBreakpoints
				Component={VerticalGallery}
				variants={defaultResponsiveVariants}
				{...rest}
			/>
		</ContextProviders>
	);
};
Object.assign(ComponentWithRoot, VerticalGallery);
var vertical_gallery_default = ComponentWithRoot;
export { vertical_gallery_default as default };
