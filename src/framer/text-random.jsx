// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 1bd92cedbbf431b3 "Sentinel AI", do not edit manually */
"use client";

/**
 * @typedef Locale
 * string
 */

/**
 * @typedef {{
 * children?: React.ReactNode
 * locale?: Locale
 * style?: React.CSSProperties
 * className?: string
 * id?: string
 * ref?: any
 * width?: any
 * height?: any
 * layoutId?: string
 * text?: string // Text
 * typography?: undefined // Typography
 * color?: string // Color
 * link?: string // Link
 * openInNewTab?: boolean // Open in new tab
 * ariaLabel?: string // Aria Label
 * duration?: number // Duration
 * fPS?: number // FPS
 * ease?: 'Linear' | 'Out' | 'InOut' // Ease
 * intensity?: number // Intensity
 * charset?: string // Charset
 * hoverOnly?: boolean // Hover only
 * restartOnHover?: boolean // Restart on hover
 * repeatOnEnter?: boolean // Repeat on enter
 * repeatAfter?: number // Repeat After
}} Props

 */
import { routes } from "./chunks/chunk-32AWGGTF.js";

// virtual:text-random
import { Fragment } from "react";
import { ContextProviders } from "unframer";

// /:https://framerusercontent.com/modules/gQWSGBSmEgeG1ODUAGWd/GIckbzH9bEOkj5CVho7o/TextRandom.js
import { jsx as _jsx } from "react/jsx-runtime";
import * as React from "react";
import { addPropertyControls, ControlType, RenderTarget } from "unframer";
import { motion, useAnimationControls } from "unframer";
var __unframerWindow = typeof window !== "undefined" ? window : void 0;
function buildIndices(len) {
	const a = new Uint16Array(len);
	for (let i = 0; i < len; i++) a[i] = i;
	return a;
}
function shuffleIndices(indices) {
	for (let i = indices.length - 1; i > 0; i--) {
		const j = (Math.random() * (i + 1)) | 0;
		const t = indices[i];
		indices[i] = indices[j];
		indices[j] = t;
	}
}
function easePortion(t, mode) {
	if (mode === "linear") return t;
	if (mode === "out") return 1 - Math.pow(1 - t, 3);
	return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}
function readFamily(f, fb) {
	if (!f || typeof f !== "object") return fb;
	return f.fontFamily || f.family || fb;
}
function readWeight(f, fb) {
	if (!f || typeof f !== "object") return fb;
	const v = f.fontWeight ?? f.weight ?? f.variant;
	const n = Number(v);
	return Number.isFinite(n) ? n : fb;
}
function readAlign(f, fb) {
	if (!f || typeof f !== "object") return fb;
	const a = f.textAlign || f.align;
	return a === "center" || a === "right" ? a : "left";
}
function readStringOrFallback(f, key, fb) {
	if (!f || typeof f !== "object") return fb;
	const v = f[key];
	return typeof v === "string" || typeof v === "number" ? String(v) : fb;
}
function extractHref(link) {
	if (!link) return null;
	if (typeof link === "string") return link.trim() || null;
	if (typeof link === "object") {
		const url = link.url ?? link.href ?? link.target ?? "";
		return url || null;
	}
	return null;
}
function openLink(href, newTab) {
	if (!href || typeof __unframerWindow === "undefined") return;
	try {
		const abs = new URL(href, __unframerWindow.location.href).toString();
		newTab
			? __unframerWindow.open(abs, "_blank", "noopener,noreferrer")
			: __unframerWindow.location.assign(abs);
	} catch (e) {
		console.warn("Invalid link:", href, e);
	}
}
function TextRandom(props) {
	const {
		text = "Hover to decode",
		font,
		color = "#111",
		link,
		newTab = true,
		ariaLabel,
		durationMs = 900,
		fps = 30,
		revealEase = "out",
		intensity = 1,
		charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%*",
		hoverOnly = true,
		repeatOnHover = true,
		repeatOnEnter = false,
		repeatAfterMs = 0,
		style = {},
	} = props;
	const family = React.useMemo(
		() =>
			readFamily(
				font,
				"Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif",
			),
		[font],
	);
	const weight = React.useMemo(() => readWeight(font, 600), [font]);
	const fontSize = React.useMemo(
		() => readStringOrFallback(font, "fontSize", "18px"),
		[font],
	);
	const lineHeight = React.useMemo(
		() => readStringOrFallback(font, "lineHeight", "1.1"),
		[font],
	);
	const letterSpacing = React.useMemo(
		() => readStringOrFallback(font, "letterSpacing", "0px"),
		[font],
	);
	const textAlign = React.useMemo(() => readAlign(font, "left"), [font]);
	const href = React.useMemo(() => extractHref(link), [link]);
	const [display, setDisplay] = React.useState(text);
	const anim = useAnimationControls();
	const base = React.useMemo(() => text, [text]);
	const maxLen = React.useMemo(() => base.length, [base]);
	const indices = React.useMemo(() => buildIndices(maxLen), [maxLen]);
	const chars = React.useMemo(() => charset.split(""), [charset]);
	React.useEffect(() => {
		if (!runningRef.current) setDisplay(base);
	}, [base]);
	const isCanvas = RenderTarget.current() === RenderTarget.canvas;
	const runningRef = React.useRef(false);
	const frameRef = React.useRef(null);
	const runScramble = React.useCallback(() => {
		if (runningRef.current) return;
		runningRef.current = true;
		const total = Math.max(1, Math.round((durationMs / 1e3) * fps));
		const revealPerFrame = new Array(total);
		for (let f = 0; f < total; f++)
			revealPerFrame[f] = easePortion((f + 1) / total, revealEase);
		const baseChars = base.split("");
		const work = new Array(maxLen);
		const order = new Uint16Array(indices);
		shuffleIndices(order);
		let frame = 0;
		const tick = () => {
			const portion = revealPerFrame[Math.min(frame, total - 1)];
			const revealedCount = Math.floor(portion * maxLen);
			const revealed = new Uint8Array(maxLen);
			for (let k = 0; k < revealedCount; k++) revealed[order[k]] = 1;
			const pending = maxLen - revealedCount;
			const scrambleBudget = Math.max(0, Math.floor(intensity * pending));
			const tailStart = revealedCount;
			const take = Math.min(scrambleBudget, maxLen - tailStart);
			const activeMask = new Uint8Array(maxLen);
			for (let i = 0; i < take; i++) activeMask[order[tailStart + i]] = 1;
			for (let i = 0; i < maxLen; i++) {
				if (revealed[i]) {
					work[i] = baseChars[i];
				} else {
					const c = chars[(Math.random() * chars.length) | 0];
					work[i] = c;
					if (!activeMask[i] && ((i + frame) & 1) === 0) {
						work[i] = chars[(Math.random() * chars.length) | 0];
					}
				}
			}
			setDisplay(work.join(""));
			frame++;
			if (frame < total) {
				frameRef.current = requestAnimationFrame(tick);
			} else {
				setDisplay(base);
				runningRef.current = false;
				frameRef.current = null;
			}
		};
		frameRef.current = requestAnimationFrame(tick);
	}, [base, maxLen, indices, chars, durationMs, fps, revealEase, intensity]);
	const onHoverStart = React.useCallback(() => {
		if (!hoverOnly) return;
		if (repeatOnHover || (!repeatOnHover && !runningRef.current)) runScramble();
		anim.start({
			opacity: 1,
		});
	}, [hoverOnly, repeatOnHover, runScramble, anim]);
	const onHoverEnd = React.useCallback(() => {
		anim.start({
			opacity: 1,
		});
	}, [anim]);
	const rootRef = React.useRef(null);
	const triggeredOnceRef = React.useRef(false);
	React.useEffect(() => {
		if (hoverOnly || isCanvas) return;
		if (typeof __unframerWindow === "undefined" || !rootRef.current) return;
		const node = rootRef.current;
		const obs = new IntersectionObserver(
			(entries) => {
				for (const e of entries) {
					const visible = e.isIntersecting && e.intersectionRatio >= 0.25;
					if (!visible) continue;
					if (!repeatOnEnter) {
						if (!triggeredOnceRef.current) {
							triggeredOnceRef.current = true;
							runScramble();
							obs.disconnect();
						}
						continue;
					}
					if (!runningRef.current) runScramble();
				}
			},
			{
				root: null,
				rootMargin: "0px",
				threshold: [0, 0.25, 0.5, 0.75, 1],
			},
		);
		obs.observe(node);
		return () => obs.disconnect();
	}, [hoverOnly, isCanvas, repeatOnEnter, runScramble]);
	React.useEffect(() => {
		if (isCanvas) return;
		if (!Number.isFinite(repeatAfterMs) || repeatAfterMs <= 0) return;
		if (typeof __unframerWindow === "undefined") return;
		const interval = __unframerWindow.setInterval(
			() => {
				if (
					typeof document !== "undefined" &&
					document.visibilityState === "hidden"
				)
					return;
				if (!runningRef.current) runScramble();
			},
			Math.max(50, repeatAfterMs | 0),
		);
		return () => clearInterval(interval);
	}, [repeatAfterMs, isCanvas, runScramble]);
	React.useEffect(() => {
		return () => {
			if (frameRef.current != null) cancelAnimationFrame(frameRef.current);
		};
	}, []);
	const role = href ? "link" : void 0;
	const tabIndex = href ? 0 : void 0;
	const aria = ariaLabel || (href ? `Open link: ${base}` : void 0);
	return (
		<motion.div
			ref={rootRef}
			role={role}
			tabIndex={tabIndex}
			aria-label={aria}
			onKeyDown={(e) => {
				if (!href) return;
				if (e.key === "Enter" || e.key === " ") {
					e.preventDefault();
					openLink(href, newTab);
				}
			}}
			onClick={() => openLink(href, newTab)}
			onHoverStart={onHoverStart}
			onHoverEnd={onHoverEnd}
			animate={anim}
			style={{
				display: "flex",
				alignItems: "center",
				justifyContent:
					textAlign === "center"
						? "center"
						: textAlign === "right"
							? "flex-end"
							: "flex-start",
				width: "100%",
				height: "100%",
				overflow: "hidden",
				cursor: href ? "pointer" : "default",
				...style,
			}}
		>
			<div
				style={{
					width: "100%",
					textAlign,
					color,
					fontFamily: family,
					fontWeight: weight,
					fontSize,
					lineHeight,
					letterSpacing,
					whiteSpace: "pre-wrap",
					wordBreak: "break-word",
					willChange: "contents",
				}}
			>
				{display}
			</div>
		</motion.div>
	);
}
addPropertyControls(TextRandom, {
	text: {
		type: ControlType.String,
		title: "Text",
		defaultValue: "Hover to decode",
		displayTextArea: true,
	},
	font: {
		type: ControlType.Font,
		title: "Typography",
		controls: "extended",
		defaultFontType: "sans-serif",
		displayTextAlignment: true,
		displayFontSize: true,
		defaultValue: {
			fontFamily: "Inter",
			fontWeight: 600,
			fontSize: "18px",
			lineHeight: "1.1",
			letterSpacing: "0px",
			textAlign: "left",
		},
	},
	color: {
		type: ControlType.Color,
		title: "Color",
		defaultValue: "#111111",
	},
	link: {
		type: ControlType.Link ?? ControlType.String,
		title: "Link",
		defaultValue: "",
	},
	newTab: {
		type: ControlType.Boolean,
		title: "Open in new tab",
		defaultValue: true,
	},
	ariaLabel: {
		type: ControlType.String,
		title: "Aria Label",
		defaultValue: "",
	},
	durationMs: {
		type: ControlType.Number,
		title: "Duration",
		min: 120,
		max: 4e3,
		step: 10,
		defaultValue: 900,
		unit: "ms",
	},
	fps: {
		type: ControlType.Number,
		title: "FPS",
		min: 12,
		max: 60,
		step: 1,
		defaultValue: 30,
	},
	revealEase: {
		type: ControlType.Enum,
		title: "Ease",
		options: ["linear", "out", "inOut"],
		optionTitles: ["Linear", "Out", "InOut"],
		defaultValue: "out",
	},
	intensity: {
		type: ControlType.Number,
		title: "Intensity",
		min: 0,
		max: 1,
		step: 0.01,
		defaultValue: 1,
	},
	charset: {
		type: ControlType.String,
		title: "Charset",
		defaultValue: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%*",
	},
	hoverOnly: {
		type: ControlType.Boolean,
		title: "Hover only",
		defaultValue: true,
	},
	repeatOnHover: {
		type: ControlType.Boolean,
		title: "Restart on hover",
		defaultValue: true,
	},
	repeatOnEnter: {
		type: ControlType.Boolean,
		title: "Repeat on enter",
		defaultValue: false,
	},
	repeatAfterMs: {
		type: ControlType.Number,
		title: "Repeat After",
		min: 0,
		max: 1e4,
		step: 50,
		unit: "ms",
		defaultValue: 0,
	},
});

// virtual:text-random
import { WithFramerBreakpoints } from "unframer";
import { jsx } from "react/jsx-runtime";
var locales = [];
var defaultResponsiveVariants = {};
/** @type {function(Props): any} */
function ComponentWithRoot({ locale, ...rest }) {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"1bd92cedbbf431b3411a7ddd12ea507e929f85a97d28da8179a9646480dcde76"
			}
			locale={locale}
			locales={locales}
		>
			<TextRandom {...rest} />
		</ContextProviders>
	);
}
/**
 * @type {import("unframer").UnframerBreakpoint}
 * Represents a responsive breakpoint for unframer.
 */

/**
 * @typedef VariantsMap
 * Partial record of UnframerBreakpoint to Props.variant, with a mandatory 'base' key.
 * { [key in UnframerBreakpoint]?: Props['variant'] } & { base: Props['variant'] }
 */

/**
 * Renders TextRandomFramerComponent for all breakpoints with a variants map. Variant prop is inferred per breakpoint.
 * @function
 * @param {Omit<Props, 'variant'> & {variants?: VariantsMap}} props
 * @returns {any}
 */
ComponentWithRoot.Responsive = ({ locale = "", ...rest }) => {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"1bd92cedbbf431b3411a7ddd12ea507e929f85a97d28da8179a9646480dcde76"
			}
			locale={locale}
			locales={locales}
		>
			<WithFramerBreakpoints
				Component={TextRandom}
				variants={defaultResponsiveVariants}
				{...rest}
			/>
		</ContextProviders>
	);
};
Object.assign(ComponentWithRoot, TextRandom);
var text_random_default = ComponentWithRoot;
export { text_random_default as default };
