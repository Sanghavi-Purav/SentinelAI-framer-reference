// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 1bd92cedbbf431b3 "Sentinel AI", do not edit manually */
"use client";

/**
 * @typedef Locale
 * string
 */

/**
 * @typedef {{
 * children?: React.ReactNode
 * locale?: Locale
 * style?: React.CSSProperties
 * className?: string
 * id?: string
 * ref?: any
 * width?: any
 * height?: any
 * layoutId?: string
 * images?: string[] // Images
 * maskSVGS?: string[] // Mask SVGs
 * maskSize?: 'Contain' | 'Cover (edge-to-edge)' | 'Fill (stretch)' // Mask Size
 * rotateMask?: number // Rotate Mask
 * gap?: number // Gap
 * cardRotX?: number // Card Rot X
 * cardRotY?: number // Card Rot Y
 * cardRotZ?: number // Card Rot Z
 * rotateCard(X,Legacy)?: number // Rotate Card (X, legacy)
 * reverseMotion?: boolean // Reverse Motion
 * slowAnimationOnHover?: boolean // Slow Animation on Hover
 * drag?: boolean // Drag
 * opacityCard?: number // Opacity Card
 * count?: number // Count
 * cardColor?: string // Card Color
 * cardW?: number // Card W
 * cardH?: number // Card H
 * radius?: number // Radius
 * speed?: number // Speed
 * perspective?: number // Perspective
 * camX?: number // Cam X
 * camY?: number // Cam Y
 * camZ?: number // Cam Z
 * offsetX?: number // Offset X
 * offsetY?: number // Offset Y
 * imageAngle?: number // Image Angle
 * stopMotionInEditor?: boolean // Stop Motion in Editor
 * thickness?: number // Thickness
 * zOffset/step?: number // Z offset/step
}} Props

 */
import { routes } from "./chunks/chunk-32AWGGTF.js";

// virtual:rotor-gallery
import { Fragment } from "react";
import { ContextProviders } from "unframer";

// /:https://framerusercontent.com/modules/fZXHxEQY1ujHv0K5UCLJ/X2XkTMBz22CYceVLCLA7/RotorGallery.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import * as React from "react";
import { addPropertyControls, ControlType } from "unframer";
var __unframerWindow = typeof window !== "undefined" ? window : void 0;
var HOVER_SPEED_FACTOR = 0.35;
var DRAG_DEG_PER_PX = 0.4;
var RotorItem = /* @__PURE__ */ React.memo(function RotorItem2({
	url,
	maskUrl,
	index,
	total,
	borderRadius,
	imgRotateDeg,
	maskRotateDeg,
	cardColor,
	maskSizeValue,
	gapPx,
	thicknessPx,
	zOffsetPx,
}) {
	const halfThick = Math.max(0, thicknessPx) / 2;
	const itemAngle = (index / total) * 360;
	const radial = gapPx + index * Math.max(0, zOffsetPx);
	const zIndex = React.useMemo(() => {
		const angle = ((itemAngle % 360) + 360) % 360;
		return angle <= 180 ? total - index : index;
	}, [index, total, itemAngle]);
	return (
		<div
			className={"ffg-item"}
			style={{
				// CSS custom properties drive transforms without re-rendering
				["--radius"]: `${borderRadius}px`,
				["--imgrot"]: `${imgRotateDeg}deg`,
				["--half"]: `${halfThick}px`,
				["--fallback"]: url ? "transparent" : cardColor,
				["--maskUrl"]: maskUrl ? `url("${maskUrl}")` : "none",
				["--maskSizeVal"]: maskSizeValue,
				["--maskrot"]: `${maskRotateDeg}deg`,
				["--item-angle"]: `${itemAngle}deg`,
				["--radial"]: `${radial}px`,
				// Per-card rotation variables (degrees), provided by parent via sceneRef
				["--card-rot-x"]: `var(--card-rot-x-deg, 0deg)`,
				["--card-rot-y"]: `var(--card-rot-y-deg, 0deg)`,
				["--card-rot-z"]: `var(--card-rot-z-deg, 0deg)`,
				// Order: ring rotation -> item placement -> card-only rotations
				transform: `rotateX(calc(var(--global-rotation) - var(--item-angle))) translateZ(var(--radial)) rotateX(var(--card-rot-x)) rotateY(var(--card-rot-y)) rotateZ(var(--card-rot-z))`,
				WebkitTransform: `rotateX(calc(var(--global-rotation) - var(--item-angle))) translateZ(var(--radial)) rotateX(var(--card-rot-x)) rotateY(var(--card-rot-y)) rotateZ(var(--card-rot-z))`,
				zIndex,
				pointerEvents: "none",
			}}
		>
			<div
				className={"ffg-maskWrap"}
				style={{
					transform: `rotateZ(${maskRotateDeg}deg)`,
					WebkitTransform: `rotateZ(${maskRotateDeg}deg)`,
					maskImage: maskUrl ? `url("${maskUrl}")` : "none",
					WebkitMaskImage: maskUrl ? `url("${maskUrl}")` : "none",
					maskSize: maskSizeValue,
					WebkitMaskSize: maskSizeValue,
					maskRepeat: "no-repeat",
					WebkitMaskRepeat: "no-repeat",
					maskPosition: "center",
					WebkitMaskPosition: "center",
				}}
			>
				<div
					className={"ffg-content"}
					style={{
						transform: `rotateZ(${-maskRotateDeg}deg)`,
						WebkitTransform: `rotateZ(${-maskRotateDeg}deg)`,
					}}
				>
					<div
						className={"ffg-face"}
						style={{
							borderRadius: `${borderRadius}px`,
							background: url ? `url("${url}") center/cover` : cardColor,
							transform: `rotateZ(90deg) translateZ(${halfThick}px) rotate(${imgRotateDeg}deg) `,
							WebkitTransform: `rotateZ(90deg) translateZ(${halfThick}px) rotate(${imgRotateDeg}deg) `,
							backfaceVisibility: "hidden",
							WebkitBackfaceVisibility: "hidden",
						}}
					/>
					<div
						className={"ffg-face ffg-back"}
						style={{
							borderRadius: `${borderRadius}px`,
							background: url ? `url("${url}") center/cover` : cardColor,
							transform: `rotateZ(90deg) rotateY(180deg) translateZ(${halfThick}px) rotate(${imgRotateDeg}deg) `,
							WebkitTransform: `rotateZ(90deg) rotateY(180deg) translateZ(${halfThick}px) rotate(${imgRotateDeg}deg) `,
							backfaceVisibility: "hidden",
							WebkitBackfaceVisibility: "hidden",
						}}
					/>
				</div>
			</div>
		</div>
	);
});
function RotorGallery(props) {
	const {
		images = [],
		masks = [],
		count = 18,
		cardColor = "#dcdcdc",
		cardWidth = 140,
		cardHeight = 140,
		borderRadius = 0,
		speedSec = 35,
		perspective = 2500,
		camX = -25,
		camY = 0,
		camZ = -100,
		offsetX = 0,
		offsetY = 0,
		imgRotateDeg = 0,
		maskRotateDeg = 0,
		gapPx = 150,
		rotateCardDeg = 90,
		stopInEditor = false,
		thicknessPx = 1,
		zOffsetPx = 0,
		maskSize = "contain",
		width = "100%",
		height = "100%",
		reverseMotion = false,
		cardRotXDeg = 0,
		cardRotYDeg = 0,
		cardRotZDeg = 0,
		cardOpacity = 1,
		slowOnHover = false,
		enableDrag = false,
	} = props;
	const mergedCardRotX = (cardRotXDeg ?? 0) + (rotateCardDeg ?? 0);
	const mergedCardRotY = cardRotYDeg ?? 0;
	const mergedCardRotZ = cardRotZDeg ?? 0;
	const list = React.useMemo(() => {
		const n2 = Math.max(0, Math.floor(count));
		if (n2 === 0) return [];
		if (images.length === 0)
			return Array.from(
				{
					length: n2,
				},
				() => "",
			);
		return Array.from(
			{
				length: n2,
			},
			(_, i) => images[i % images.length],
		);
	}, [images, count]);
	const maskList = React.useMemo(() => {
		const n2 = Math.max(0, Math.floor(count));
		if (n2 === 0 || masks.length === 0)
			return Array.from(
				{
					length: n2,
				},
				() => "",
			);
		return Array.from(
			{
				length: n2,
			},
			(_, i) => masks[i % masks.length],
		);
	}, [masks, count]);
	const [isEditor, setIsEditor] = React.useState(false);
	React.useEffect(() => {
		try {
			const inIframe = __unframerWindow.self !== __unframerWindow.top;
			const ref = document.referrer || "";
			const framerRef = /(framer\.com|framer\.app)/i.test(ref);
			const framerGlobal =
				inIframe &&
				__unframerWindow.framer &&
				typeof __unframerWindow.framer === "object";
			setIsEditor(inIframe && (framerRef || framerGlobal));
		} catch {
			setIsEditor(false);
		}
	}, []);
	const [isVisible, setIsVisible] = React.useState(true);
	const sceneRef = React.useRef(null);
	const rootRef = React.useRef(null);
	React.useEffect(() => {
		const el = sceneRef.current;
		if (!el || typeof IntersectionObserver === "undefined") return;
		const observer = new IntersectionObserver(
			(entries) => {
				for (const entry of entries) {
					if (entry.target === el) {
						setIsVisible(entry.isIntersecting);
					}
				}
			},
			{
				threshold: 0.1,
			},
		);
		observer.observe(el);
		return () => observer.disconnect();
	}, []);
	const paused = (stopInEditor && isEditor) || speedSec <= 0 || !isVisible;
	const [isHovered, setIsHovered] = React.useState(false);
	const [isDragging, setIsDragging] = React.useState(false);
	const dragActiveRef = React.useRef(false);
	const dragStartXRef = React.useRef(0);
	const dragStartAngleRef = React.useRef(0);
	const last = React.useRef({
		w: Number(cardWidth) || 140,
		h: Number(cardHeight) || 140,
	});
	React.useLayoutEffect(() => {
		const el = sceneRef.current;
		if (!el) return;
		const w = Number(cardWidth),
			h = Number(cardHeight);
		if (Number.isFinite(w) && w > 0 && w !== last.current.w) {
			el.style.width = `${w}px`;
			last.current.w = w;
		}
		if (Number.isFinite(h) && h > 0 && h !== last.current.h) {
			el.style.height = `${h}px`;
			last.current.h = h;
		}
	}, [cardWidth, cardHeight]);
	const animationRef = React.useRef(null);
	const angleRef = React.useRef(0);
	const lastTimeRef = React.useRef(null);
	React.useEffect(() => {
		if (paused) {
			if (animationRef.current) {
				cancelAnimationFrame(animationRef.current);
				animationRef.current = null;
			}
			if (sceneRef.current) {
				sceneRef.current.style.setProperty(
					"--card-rot-x-deg",
					`${mergedCardRotX}deg`,
				);
				sceneRef.current.style.setProperty(
					"--card-rot-y-deg",
					`${mergedCardRotY}deg`,
				);
				sceneRef.current.style.setProperty(
					"--card-rot-z-deg",
					`${mergedCardRotZ}deg`,
				);
				sceneRef.current.style.setProperty(
					"--card-opacity",
					`${Math.max(0, Math.min(1, cardOpacity))}`,
				);
				sceneRef.current.style.setProperty(
					"--global-rotation",
					`${angleRef.current}deg`,
				);
			}
			lastTimeRef.current = null;
			return;
		}
		const durationMs = Math.max(1e-4, speedSec * 1e3);
		const baseDegPerMs = 360 / durationMs;
		lastTimeRef.current = null;
		const frame = (t) => {
			if (!sceneRef.current) {
				animationRef.current = requestAnimationFrame(frame);
				return;
			}
			if (lastTimeRef.current === null) {
				lastTimeRef.current = t;
			} else {
				const deltaMs = t - lastTimeRef.current;
				lastTimeRef.current = t;
				if (!dragActiveRef.current) {
					const direction = reverseMotion ? 1 : -1;
					const speedFactor = slowOnHover && isHovered ? HOVER_SPEED_FACTOR : 1;
					const degDelta = direction * baseDegPerMs * deltaMs * speedFactor;
					angleRef.current = (angleRef.current + degDelta) % 360;
				} else {
				}
			}
			sceneRef.current.style.setProperty(
				"--global-rotation",
				`${angleRef.current}deg`,
			);
			sceneRef.current.style.setProperty(
				"--card-rot-x-deg",
				`${mergedCardRotX}deg`,
			);
			sceneRef.current.style.setProperty(
				"--card-rot-y-deg",
				`${mergedCardRotY}deg`,
			);
			sceneRef.current.style.setProperty(
				"--card-rot-z-deg",
				`${mergedCardRotZ}deg`,
			);
			sceneRef.current.style.setProperty(
				"--card-opacity",
				`${Math.max(0, Math.min(1, cardOpacity))}`,
			);
			animationRef.current = requestAnimationFrame(frame);
		};
		animationRef.current = requestAnimationFrame(frame);
		return () => {
			if (animationRef.current) {
				cancelAnimationFrame(animationRef.current);
				animationRef.current = null;
			}
		};
	}, [
		paused,
		speedSec,
		reverseMotion,
		mergedCardRotX,
		mergedCardRotY,
		mergedCardRotZ,
		cardOpacity,
		slowOnHover,
		isHovered,
	]);
	const n = Math.max(1, list.length);
	const maskSizeValue = maskSize === "contain" ? "contain" : "100% 100%";
	const handlePointerDown = (e) => {
		if (!enableDrag) return;
		if ((stopInEditor && isEditor) || !isVisible) return;
		dragActiveRef.current = true;
		dragStartXRef.current = e.clientX;
		dragStartAngleRef.current = angleRef.current;
		lastTimeRef.current = null;
		setIsDragging(true);
		try {
			e.currentTarget.setPointerCapture(e.pointerId);
		} catch {}
		e.preventDefault();
	};
	const handlePointerMove = (e) => {
		if (!enableDrag || !dragActiveRef.current) return;
		const dx = dragStartXRef.current - e.clientX;
		angleRef.current = dragStartAngleRef.current + dx * DRAG_DEG_PER_PX;
		if (sceneRef.current) {
			sceneRef.current.style.setProperty(
				"--global-rotation",
				`${angleRef.current}deg`,
			);
		}
		lastTimeRef.current = null;
		e.preventDefault();
	};
	const endDrag = (e) => {
		if (!dragActiveRef.current) return;
		dragActiveRef.current = false;
		dragStartXRef.current = 0;
		dragStartAngleRef.current = angleRef.current;
		lastTimeRef.current = null;
		setIsDragging(false);
		try {
			e.currentTarget.releasePointerCapture(e.pointerId);
		} catch {}
	};
	return (
		<div
			ref={rootRef}
			style={{
				width,
				height,
				position: "relative",
				perspective: `${perspective}px`,
				perspectiveOrigin: "50% 50%",
				overflow: "visible",
				cursor: enableDrag ? (isDragging ? "grabbing" : "grab") : "default",
			}}
			onMouseEnter={() => setIsHovered(true)}
			onMouseLeave={() => setIsHovered(false)}
			onPointerDown={handlePointerDown}
			onPointerMove={handlePointerMove}
			onPointerUp={endDrag}
			onPointerLeave={endDrag}
			onPointerCancel={endDrag}
		>
			<style>{`
                .ffg-scene {
                    position: relative;
                    transform-style: preserve-3d;
                    -webkit-transform-style: preserve-3d;
                    --global-rotation: 0deg;
                    /* Card rotations (degrees) */
                    --card-rot-x-deg: 0deg;
                    --card-rot-y-deg: 0deg;
                    --card-rot-z-deg: 0deg;
                    /* Card opacity */
                    --card-opacity: 1;
                }
                
                .ffg-list {
                    position: relative;
                    width: 100%;
                    height: 100%;
                    transform-style: preserve-3d;
                    -webkit-transform-style: preserve-3d;
                }
                
                .ffg-item {
                    contain: layout style;
                    position: absolute;
                    inset: 0;
                    transform-style: preserve-3d;
                    -webkit-transform-style: preserve-3d;
                    transform-origin: center center;
                    -webkit-transform-origin: center center;
                }
                .ffg-scene,
.ffg-list,
.ffg-item,
.ffg-maskWrap,
.ffg-content {
    will-change: transform;

    transform: translateZ(0);
}
                .ffg-maskWrap {
                    position: absolute;
                    inset: 0;
                    transform-style: preserve-3d;
                    -webkit-transform-style: preserve-3d;
                }
                
                .ffg-content {
                    position: absolute;
                    inset: 0;
                    transform-style: preserve-3d;
                    -webkit-transform-style: preserve-3d;
                }
                
                .ffg-face {
                    position: absolute;
                    inset: 0;
                    overflow: hidden;
                    border-radius: var(--radius);
                    backface-visibility: hidden;
                    -webkit-backface-visibility: hidden;

                    background-position: center;
                    background-size: cover;
                    background-repeat: no-repeat;



                    /* Opacity is applied directly to card faces */
                    opacity: var(--card-opacity, 1);
                }
            `}</style>
			<div
				ref={sceneRef}
				className={"ffg-scene"}
				style={{
					position: "absolute",
					top: "50%",
					left: "50%",
					transform: "translate(-50%, -50%)",
					width: `${last.current.w}px`,
					height: `${last.current.h}px`,
				}}
			>
				<div
					className={"ffg-list"}
					style={{
						transform: `translate3d(${offsetX}px, ${offsetY}px, 0) rotateX(${camX}deg) rotateY(${camY}deg) rotateZ(${camZ}deg)`,
						WebkitTransform: `translate3d(${offsetX}px, ${offsetY}px, 0) rotateX(${camX}deg) rotateY(${camY}deg) rotateZ(${camZ}deg)`,
					}}
				>
					{list.map((url, i) => (
						<RotorItem
							url={url}
							maskUrl={maskList[i]}
							index={i}
							total={n}
							borderRadius={borderRadius}
							imgRotateDeg={imgRotateDeg}
							maskRotateDeg={maskRotateDeg}
							cardColor={cardColor}
							maskSizeValue={maskSizeValue}
							gapPx={gapPx}
							thicknessPx={thicknessPx}
							zOffsetPx={zOffsetPx}
						/>
					))}
				</div>
			</div>
		</div>
	);
}
addPropertyControls(RotorGallery, {
	images: {
		title: "Images",
		type: ControlType.Array,
		control: {
			type: ControlType.Image,
		},
	},
	masks: {
		title: "Mask SVGs",
		type: ControlType.Array,
		control: {
			type: ControlType.File,
			allowedFileTypes: [".svg"],
		},
	},
	maskSize: {
		title: "Mask Size",
		type: ControlType.Enum,
		options: ["contain", "cover", "fill"],
		optionTitles: ["Contain", "Cover (edge-to-edge)", "Fill (stretch)"],
		defaultValue: "contain",
	},
	maskRotateDeg: {
		title: "Rotate Mask",
		type: ControlType.Number,
		min: -180,
		max: 180,
		step: 1,
		unit: "\xB0",
		defaultValue: 0,
	},
	gapPx: {
		title: "Gap",
		type: ControlType.Number,
		min: -500,
		max: 500,
		step: 1,
		unit: "px",
		defaultValue: 150,
	},
	// Per-card rotations (only the card)
	cardRotXDeg: {
		title: "Card Rot X",
		type: ControlType.Number,
		min: -180,
		max: 180,
		step: 1,
		unit: "\xB0",
		defaultValue: 0,
	},
	cardRotYDeg: {
		title: "Card Rot Y",
		type: ControlType.Number,
		min: -180,
		max: 180,
		step: 1,
		unit: "\xB0",
		defaultValue: 0,
	},
	cardRotZDeg: {
		title: "Card Rot Z",
		type: ControlType.Number,
		min: -180,
		max: 180,
		step: 1,
		unit: "\xB0",
		defaultValue: 0,
	},
	// Legacy single-axis tilt kept (maps into Card Rot X)
	rotateCardDeg: {
		title: "Rotate Card (X, legacy)",
		type: ControlType.Number,
		min: -90,
		max: 90,
		step: 1,
		unit: "\xB0",
		defaultValue: 90,
	},
	// Reverse motion toggle
	reverseMotion: {
		title: "Reverse Motion",
		type: ControlType.Boolean,
		enabledTitle: "On",
		disabledTitle: "Off",
		defaultValue: false,
	},
	// Slow animation on hover
	slowOnHover: {
		title: "Slow Animation on Hover",
		type: ControlType.Boolean,
		enabledTitle: "On",
		disabledTitle: "Off",
		defaultValue: false,
	},
	// Drag toggle
	enableDrag: {
		title: "Drag",
		type: ControlType.Boolean,
		enabledTitle: "On",
		disabledTitle: "Off",
		defaultValue: false,
	},
	// Opacity Card
	cardOpacity: {
		title: "Opacity Card",
		type: ControlType.Number,
		min: 0,
		max: 1,
		step: 0.01,
		defaultValue: 1,
	},
	count: {
		title: "Count",
		type: ControlType.Number,
		min: 1,
		max: 40,
		step: 1,
		defaultValue: 12,
	},
	cardColor: {
		title: "Card Color",
		type: ControlType.Color,
		defaultValue: "#dcdcdc",
	},
	cardWidth: {
		title: "Card W",
		type: ControlType.Number,
		min: 20,
		max: 600,
		unit: "px",
		defaultValue: 200,
	},
	cardHeight: {
		title: "Card H",
		type: ControlType.Number,
		min: 20,
		max: 600,
		unit: "px",
		defaultValue: 200,
	},
	borderRadius: {
		title: "Radius",
		type: ControlType.Number,
		min: 0,
		max: 500,
		unit: "px",
		defaultValue: 0,
	},
	speedSec: {
		title: "Speed",
		type: ControlType.Number,
		min: 0,
		max: 100,
		step: 0.25,
		unit: "s",
		defaultValue: 35,
	},
	perspective: {
		title: "Perspective",
		type: ControlType.Number,
		min: 200,
		max: 3e3,
		step: 10,
		unit: "px",
		defaultValue: 2500,
	},
	camX: {
		title: "Cam X",
		type: ControlType.Number,
		min: -90,
		max: 90,
		unit: "\xB0",
		defaultValue: -25,
	},
	camY: {
		title: "Cam Y",
		type: ControlType.Number,
		min: -90,
		max: 90,
		unit: "\xB0",
		defaultValue: 0,
	},
	camZ: {
		title: "Cam Z",
		type: ControlType.Number,
		min: -180,
		max: 180,
		unit: "\xB0",
		defaultValue: -100,
	},
	offsetX: {
		title: "Offset X",
		type: ControlType.Number,
		min: -800,
		max: 800,
		step: 1,
		unit: "px",
		defaultValue: 0,
	},
	offsetY: {
		title: "Offset Y",
		type: ControlType.Number,
		min: -800,
		max: 800,
		step: 1,
		unit: "px",
		defaultValue: 0,
	},
	imgRotateDeg: {
		title: "Image Angle",
		type: ControlType.Number,
		min: -180,
		max: 180,
		step: 1,
		unit: "\xB0",
		defaultValue: 0,
	},
	stopInEditor: {
		title: "Stop Motion in Editor",
		type: ControlType.Boolean,
		enabledTitle: "Yes",
		disabledTitle: "No",
		defaultValue: false,
	},
	thicknessPx: {
		title: "Thickness",
		type: ControlType.Number,
		min: 0,
		max: 5,
		step: 0.1,
		unit: "px",
		defaultValue: 1,
	},
	zOffsetPx: {
		title: "Z offset/step",
		type: ControlType.Number,
		min: 0,
		max: 10,
		step: 0.1,
		unit: "px",
		defaultValue: 0,
	},
});

// virtual:rotor-gallery
import { WithFramerBreakpoints } from "unframer";
import { jsx } from "react/jsx-runtime";
var locales = [];
var defaultResponsiveVariants = {};
/** @type {function(Props): any} */
function ComponentWithRoot({ locale, ...rest }) {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"1bd92cedbbf431b3411a7ddd12ea507e929f85a97d28da8179a9646480dcde76"
			}
			locale={locale}
			locales={locales}
		>
			<RotorGallery {...rest} />
		</ContextProviders>
	);
}
/**
 * @type {import("unframer").UnframerBreakpoint}
 * Represents a responsive breakpoint for unframer.
 */

/**
 * @typedef VariantsMap
 * Partial record of UnframerBreakpoint to Props.variant, with a mandatory 'base' key.
 * { [key in UnframerBreakpoint]?: Props['variant'] } & { base: Props['variant'] }
 */

/**
 * Renders RotorGalleryFramerComponent for all breakpoints with a variants map. Variant prop is inferred per breakpoint.
 * @function
 * @param {Omit<Props, 'variant'> & {variants?: VariantsMap}} props
 * @returns {any}
 */
ComponentWithRoot.Responsive = ({ locale = "", ...rest }) => {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"1bd92cedbbf431b3411a7ddd12ea507e929f85a97d28da8179a9646480dcde76"
			}
			locale={locale}
			locales={locales}
		>
			<WithFramerBreakpoints
				Component={RotorGallery}
				variants={defaultResponsiveVariants}
				{...rest}
			/>
		</ContextProviders>
	);
};
Object.assign(ComponentWithRoot, RotorGallery);
var rotor_gallery_default = ComponentWithRoot;
export { rotor_gallery_default as default };
