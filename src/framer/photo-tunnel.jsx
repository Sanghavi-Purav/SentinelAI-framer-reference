// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 1bd92cedbbf431b3 "Sentinel AI", do not edit manually */
"use client";

/**
 * @typedef Locale
 * string
 */

/**
 * @typedef {{
 * children?: React.ReactNode
 * locale?: Locale
 * style?: React.CSSProperties
 * className?: string
 * id?: string
 * ref?: any
 * width?: any
 * height?: any
 * layoutId?: string
 * images?: string[] // Images
 * smoothing?: number // Smoothing
}} Props

 */
import { routes } from "./chunks/chunk-32AWGGTF.js";

// virtual:photo-tunnel
import { Fragment } from "react";
import { ContextProviders } from "unframer";

// /:https://framerusercontent.com/modules/g4UH3wNgGcfINr9AGXYd/pf8ymQhHKIYFuXcEbCIF/PhotoTunnel.js
import { jsx as _jsx } from "react/jsx-runtime";
import { useEffect, useMemo, useRef } from "react";
import { addPropertyControls, ControlType, RenderTarget } from "unframer";
import * as THREE from "three";
var __unframerWindow = typeof window !== "undefined" ? window : void 0;
var WALL_X_MIN = 7.6;
var WALL_X_MAX = 12.2;
var Y_MIN = -2.4;
var Y_MAX = 2.4;
var Z_SPACING = 5;
var SECTIONS = 40;
var Z_MAX = SECTIONS * Z_SPACING;
var Z_MIN_GAP = 4.5;
var Z_EXTRA = 4.5;
var Z_WOBBLE = 5.25;
var EDGE_GAP_BOOST = 0.8;
var BASE_W = 7;
var CAMERA_FOV = 60;
var START_Z = 1;
var FAR_PAD = 80;
var LOOK_PARALLAX = -0.55;
var CORNER_RADIUS_UV = 0;
function PhotoTunnel(props) {
	const sectionRef = useRef(null);
	const viewRef = useRef(null);
	const images = useMemo(() => {
		const takeUrl = (v) =>
			typeof v === "string"
				? v
				: v?.src || v?.url || v?.image?.src || v?.image?.url || "";
		const arr = (props.images || []).map(takeUrl).filter(Boolean).slice(0, 20);
		for (let i = arr.length - 1; i > 0; i--) {
			const j = Math.floor(Math.random() * (i + 1));
			[arr[i], arr[j]] = [arr[j], arr[i]];
		}
		return arr;
	}, [props.images]);
	useEffect(() => {
		const section = sectionRef.current;
		const view = viewRef.current;
		if (!section || !view) return;
		view.innerHTML = "";
		if (images.length === 0) return;
		const inEditor =
			RenderTarget.current() === RenderTarget.canvas ||
			RenderTarget.current() === RenderTarget.thumbnail;
		const canvasEl = document.createElement("canvas");
		canvasEl.style.width = "100%";
		canvasEl.style.height = "100%";
		canvasEl.style.display = "block";
		view.appendChild(canvasEl);
		const getSize = () => {
			const w = view.clientWidth || 1;
			const h = view.clientHeight || 1;
			const dpr = Math.min(__unframerWindow.devicePixelRatio || 1, 2);
			return {
				w,
				h,
				dpr,
			};
		};
		if (inEditor || !supportsOffscreen()) {
			const { dispose } = renderOneFrameMainThread({
				canvasEl,
				view,
				images,
			});
			return () => {
				dispose();
				if (canvasEl.parentElement === view) view.removeChild(canvasEl);
			};
		}
		let worker = null;
		let rafId = 0;
		try {
			const off = canvasEl.transferControlToOffscreen();
			const workerURL = makeWorkerURL();
			worker = new Worker(workerURL, {
				type: "classic",
			});
			const sendResize = () => {
				const { w: w2, h: h2, dpr: dpr2 } = getSize();
				worker?.postMessage({
					type: "resize",
					width: w2,
					height: h2,
					dpr: dpr2,
				});
			};
			const { w, h, dpr } = getSize();
			worker.postMessage(
				{
					type: "init",
					canvas: off,
					width: w,
					height: h,
					dpr,
					smooth: clamp(props.smooth ?? 0.08, 0.02, 0.2),
					images,
					constants: {
						WALL_X_MIN,
						WALL_X_MAX,
						Y_MIN,
						Y_MAX,
						Z_MAX,
						Z_MIN_GAP,
						Z_EXTRA,
						Z_WOBBLE,
						EDGE_GAP_BOOST,
						BASE_W,
						CAMERA_FOV,
						START_Z,
						FAR_PAD,
						LOOK_PARALLAX,
						CORNER_RADIUS_UV,
					},
				},
				[off],
			);
			const ro = new ResizeObserver(sendResize);
			ro.observe(view);
			const onPointer = (e) => {
				const r = view.getBoundingClientRect();
				const x = ((e.clientX - r.left) / r.width) * 2 - 1;
				const y = ((e.clientY - r.top) / r.height) * 2 - 1;
				worker?.postMessage({
					type: "pointer",
					x,
					y,
				});
			};
			view.addEventListener("pointermove", onPointer, {
				passive: true,
			});
			const pathLen = Z_MAX + FAR_PAD;
			const loop = () => {
				const rect = section.getBoundingClientRect();
				const vh = __unframerWindow.innerHeight || 1;
				const t = clamp((vh - rect.top) / (rect.height + vh), 0, 1);
				const targetZ = t * pathLen;
				worker?.postMessage({
					type: "progress",
					targetZ,
				});
				rafId = requestAnimationFrame(loop);
			};
			rafId = requestAnimationFrame(loop);
			return () => {
				cancelAnimationFrame(rafId);
				view.removeEventListener("pointermove", onPointer);
				ro.disconnect();
				if (worker) {
					try {
						worker.postMessage({
							type: "dispose",
						});
						worker.terminate();
					} catch {}
				}
				URL.revokeObjectURL(workerURL);
				if (canvasEl.parentElement === view) view.removeChild(canvasEl);
			};
		} catch {
			const { dispose } = renderOneFrameMainThread({
				canvasEl,
				view,
				images,
			});
			return () => {
				dispose();
				if (canvasEl.parentElement === view) view.removeChild(canvasEl);
			};
		}
	}, [images, props.smooth]);
	return (
		<div
			ref={sectionRef}
			style={{
				width: "100%",
				height: "100%",
				position: "relative",
				background: "transparent",
				overflow: "visible",
			}}
		>
			<div
				ref={viewRef}
				style={{
					position: "sticky",
					top: 0,
					width: "100%",
					height: "100vh",
					display: "grid",
					placeItems: "center",
					overflow: "hidden",
					background: "transparent",
				}}
			/>
		</div>
	);
}
function clamp(v, lo, hi) {
	return Math.max(lo, Math.min(hi, v));
}
function supportsOffscreen() {
	return (
		typeof HTMLCanvasElement?.prototype?.transferControlToOffscreen ===
			"function" && typeof Worker !== "undefined"
	);
}
function renderOneFrameMainThread(args) {
	const { canvasEl, view, images } = args;
	const renderer = new THREE.WebGLRenderer({
		canvas: canvasEl,
		antialias: true,
		alpha: true,
		premultipliedAlpha: true,
		powerPreference: "high-performance",
	});
	const setSize = () => {
		const w = view.clientWidth || 1;
		const h = view.clientHeight || 1;
		const dpr = Math.min(__unframerWindow.devicePixelRatio || 1, 2);
		renderer.setPixelRatio(dpr);
		renderer.setSize(w, h, false);
	};
	setSize();
	renderer.outputColorSpace = THREE.SRGBColorSpace;
	renderer.setClearColor(0, 0);
	const scene = new THREE.Scene();
	scene.fog = new THREE.FogExp2(0, 0.025);
	const camera = new THREE.PerspectiveCamera(
		CAMERA_FOV,
		(view.clientWidth || 1) / (view.clientHeight || 1),
		0.1,
		FAR_PAD + Z_MAX + 100,
	);
	camera.position.set(0, 0, START_Z);
	camera.lookAt(0, 0, START_Z + 10);
	scene.add(new THREE.AmbientLight(16777215, 0.85));
	const dir = new THREE.DirectionalLight(16777215, 0.55);
	dir.position.set(1, 2, 1);
	scene.add(dir);
	const planeGeo = new THREE.PlaneGeometry(1, 1);
	const maskTex = roundedAlphaTextureMain(CORNER_RADIUS_UV, 256);
	const leftZ = buildZTrack(
		Z_MAX,
		Z_MIN_GAP,
		Z_EXTRA,
		Math.random() * Z_MIN_GAP,
	);
	const rightZ = buildZTrack(
		Z_MAX,
		Z_MIN_GAP,
		Z_EXTRA,
		Math.random() * Z_MIN_GAP * 0.6,
	);
	let idx = 0;
	const nextImg = () => images[idx++ % images.length];
	const loader = new THREE.TextureLoader();
	loader.crossOrigin = "anonymous";
	const meshes = [];
	const placeSide = (side, zs) => {
		for (const z of zs) {
			const maybePair = Math.random() < 0.2 ? 2 : 1;
			for (let k = 0; k < maybePair; k++) {
				const url = nextImg();
				const map = loader.load(
					url,
					(tex) => {
						tex.colorSpace = THREE.SRGBColorSpace;
						tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
						tex.generateMipmaps = true;
						const caps = renderer.capabilities;
						const aniso =
							(typeof caps.getMaxAnisotropy === "function"
								? caps.getMaxAnisotropy()
								: caps.maxAnisotropy) || 4;
						tex.anisotropy = aniso;
						fitPlaneToTextureMain(mesh, BASE_W);
						renderer.render(scene, camera);
					},
					void 0,
					() => {},
				);
				const mat = new THREE.MeshBasicMaterial({
					map,
					alphaMap: maskTex,
					transparent: true,
					alphaTest: 1e-3,
					depthWrite: false,
					fog: true,
					side: THREE.DoubleSide,
				});
				const mesh = new THREE.Mesh(planeGeo, mat);
				const x =
					side * (WALL_X_MIN + Math.random() * (WALL_X_MAX - WALL_X_MIN));
				const y = Y_MIN + Math.random() * (Y_MAX - Y_MIN);
				const u = z / Z_MAX;
				const edgeFactor =
					1 + EDGE_GAP_BOOST * Math.pow(Math.abs(2 * u - 1), 1.5);
				const pairOffset =
					k > 0
						? randRange(Z_MIN_GAP * 0.35, Z_MIN_GAP * 0.6) *
							edgeFactor *
							(Math.random() < 0.5 ? -1 : 1)
						: 0;
				const zLocal = z + pairOffset;
				mesh.position.set(x, y, zLocal);
				mesh.lookAt(0, y, zLocal);
				scene.add(mesh);
				meshes.push(mesh);
			}
		}
	};
	placeSide(-1, leftZ);
	placeSide(1, rightZ);
	renderer.render(scene, camera);
	const ro = new ResizeObserver(() => {
		setSize();
		camera.aspect = (view.clientWidth || 1) / (view.clientHeight || 1);
		camera.updateProjectionMatrix();
		renderer.render(scene, camera);
	});
	ro.observe(view);
	const dispose = () => {
		try {
			ro.disconnect();
			meshes.forEach((m) => {
				const mat = m.material;
				mat.map?.dispose();
				mat.alphaMap?.dispose();
				mat.dispose();
				m.geometry.dispose();
				scene.remove(m);
			});
			planeGeo.dispose();
			maskTex.dispose();
			renderer.dispose();
		} catch {}
	};
	return {
		dispose,
	};
}
function randRange(a, b) {
	return a + Math.random() * (b - a);
}
function buildZTrack(maxZ, minGap, extra, phase = 0) {
	const zs = [];
	let z = randRange(0, minGap) + phase;
	while (z < maxZ) {
		const u = z / maxZ;
		const edgeFactor = 1 + EDGE_GAP_BOOST * Math.pow(Math.abs(2 * u - 1), 1.5);
		zs.push(z + randRange(-Z_WOBBLE, Z_WOBBLE));
		z += minGap * edgeFactor + Math.random() * (extra * edgeFactor);
	}
	return zs;
}
function fitPlaneToTextureMain(mesh, baseW = BASE_W) {
	const img = mesh.material?.map?.image;
	if (!img || !img.width || !img.height) return;
	const aspect = img.width / img.height;
	const w = baseW;
	const h = w / aspect;
	mesh.scale.set(w, h, 1);
}
function roundedAlphaTextureMain(radiusUV = CORNER_RADIUS_UV, size = 256) {
	const c = document.createElement("canvas");
	c.width = c.height = size;
	const ctx = c.getContext("2d");
	ctx.clearRect(0, 0, size, size);
	ctx.fillStyle = "#000";
	ctx.fillRect(0, 0, size, size);
	ctx.fillStyle = "#fff";
	const r = Math.max(0, Math.min(0.5, radiusUV)) * size;
	roundRect(ctx, 0, 0, size, size, r);
	ctx.fill();
	const tex = new THREE.CanvasTexture(c);
	tex.generateMipmaps = false;
	tex.minFilter = THREE.LinearFilter;
	tex.magFilter = THREE.LinearFilter;
	tex.colorSpace = THREE.NoColorSpace;
	tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
	return tex;
}
function roundRect(ctx, x, y, w, h, r) {
	const rr = Math.min(r, w / 2, h / 2);
	ctx.beginPath();
	ctx.moveTo(x + rr, y);
	ctx.arcTo(x + w, y, x + w, y + h, rr);
	ctx.arcTo(x + w, y + h, x, y + h, rr);
	ctx.arcTo(x, y + h, x, y, rr);
	ctx.arcTo(x, y, x + w, y, rr);
	ctx.closePath();
}
function makeWorkerURL() {
	const src = `
    /* Worker: PhotoTunnel */
    self.importScripts('https://unpkg.com/three@0.160.0/build/three.min.js');

    let renderer, scene, camera, canvas;
    let width = 1, height = 1, dpr = 1;
    let SMOOTH = 0.08;
    let zCurrent = ${START_Z};
    let targetZ = 0;
    let mouseX = 0, mouseY = 0;
    let running = false;

    let CONST = ${JSON.stringify({
			WALL_X_MIN,
			WALL_X_MAX,
			Y_MIN,
			Y_MAX,
			Z_MAX,
			Z_MIN_GAP,
			Z_EXTRA,
			Z_WOBBLE,
			EDGE_GAP_BOOST,
			BASE_W,
			CAMERA_FOV,
			START_Z,
			FAR_PAD,
			LOOK_PARALLAX,
			CORNER_RADIUS_UV,
		})};

    const meshes = [];
    let planeGeo = null;
    let maskTex = null;

    // Helpers
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const rand = (a, b) => a + Math.random() * (b - a);

    function buildZTrack(maxZ, minGap, extra, phase = 0){
        const zs = [];
        let z = rand(0, minGap) + phase;
        while (z < maxZ) {
            const u = z / maxZ;
            const edgeFactor = 1 + CONST.EDGE_GAP_BOOST * Math.pow(Math.abs(2*u - 1), 1.5);
            zs.push(z + rand(-CONST.Z_WOBBLE, CONST.Z_WOBBLE));
            z += minGap * edgeFactor + Math.random() * (extra * edgeFactor);
        }
        return zs;
    }

    function roundedAlphaTexture(radiusUV = CONST.CORNER_RADIUS_UV, size = 256){
        const c = new OffscreenCanvas(size, size);
        const ctx = c.getContext('2d');
        ctx.clearRect(0,0,size,size);
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,size,size);
        ctx.fillStyle = '#fff';
        const r = Math.max(0, Math.min(0.5, radiusUV)) * size;
        // round rect
        const rr = Math.min(r, size/2, size/2);
        ctx.beginPath();
        ctx.moveTo(rr, 0);
        ctx.arcTo(size, 0, size, size, rr);
        ctx.arcTo(size, size, 0, size, rr);
        ctx.arcTo(0, size, 0, 0, rr);
        ctx.arcTo(0, 0, size, 0, rr);
        ctx.closePath();
        ctx.fill();

        const tex = new self.THREE.CanvasTexture(c);
        tex.generateMipmaps = false;
        tex.minFilter = self.THREE.LinearFilter;
        tex.magFilter = self.THREE.LinearFilter;
        tex.colorSpace = self.THREE.NoColorSpace;
        tex.wrapS = tex.wrapT = self.THREE.ClampToEdgeWrapping;
        return tex;
    }

    async function loadTexture(url){
        try{
            const res = await fetch(url, { mode: 'cors' });
            const blob = await res.blob();
            const bmp = await createImageBitmap(blob, { premultiplyAlpha: 'none' });
            const tex = new self.THREE.Texture(bmp);
            tex.needsUpdate = true;
            tex.colorSpace = self.THREE.SRGBColorSpace;
            tex.wrapS = tex.wrapT = self.THREE.ClampToEdgeWrapping;
            return { tex, w: bmp.width, h: bmp.height };
        }catch(e){
            const oc = new OffscreenCanvas(1,1);
            const ctx = oc.getContext('2d');
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,1,1);
            const tex = new self.THREE.CanvasTexture(oc);
            tex.needsUpdate = true;
            tex.colorSpace = self.THREE.NoColorSpace;
            return { tex, w: 1, h: 1 };
        }
    }

    function fitPlane(mesh, imgW, imgH, baseW){
        if(!imgW || !imgH) return;
        const aspect = imgW / imgH;
        const w = baseW;
        const h = w / aspect;
        mesh.scale.set(w, h, 1);
    }

    async function placeSide(side, zs, next){
        for(const z of zs){
            const maybePair = Math.random() < 0.2 ? 2 : 1;
            for(let k=0;k<maybePair;k++){
                const url = next();
                // placeholder 1x1 to avoid missing material
                const ph = new OffscreenCanvas(1,1);
                const phTex = new self.THREE.CanvasTexture(ph);
                const mat = new self.THREE.MeshBasicMaterial({
                    map: phTex,
                    alphaMap: maskTex,
                    transparent: true,
                    alphaTest: 0.001,
                    depthWrite: false,
                    fog: true,
                    side: self.THREE.DoubleSide
                });
                const mesh = new self.THREE.Mesh(planeGeo, mat);

                const x = side * rand(CONST.WALL_X_MIN, CONST.WALL_X_MAX);
                const y = rand(CONST.Y_MIN, CONST.Y_MAX);

                const u = z / CONST.Z_MAX;
                const edgeFactor = 1 + CONST.EDGE_GAP_BOOST * Math.pow(Math.abs(2*u - 1), 1.5);
                const pairOffset = k>0
                    ? rand(CONST.Z_MIN_GAP*0.35, CONST.Z_MIN_GAP*0.6)*edgeFactor*(Math.random()<0.5?-1:1)
                    : 0;
                const zLocal = z + pairOffset;

                mesh.position.set(x, y, zLocal);
                mesh.lookAt(0, y, zLocal);
                scene.add(mesh);
                meshes.push(mesh);

                // Load real texture async and update
                loadTexture(url).then(({tex, w, h})=>{
                    mat.map?.dispose();
                    mat.map = tex;
                    fitPlane(mesh, w, h, CONST.BASE_W);
                    mat.needsUpdate = true;
                }).catch(()=>{});
            }
        }
    }

    function resize({width: W, height: H, dpr: DPR}){
        width = Math.max(1, W|0); height = Math.max(1, H|0); dpr = Math.max(1, Math.min(2, DPR||1));
        renderer.setPixelRatio(dpr);
        renderer.setSize(width, height, false);
        camera.aspect = width/height;
        camera.updateProjectionMatrix();
    }

    function tick(){
        if(!running) return;
        // simple ~60fps loop
        zCurrent += (targetZ - zCurrent) * SMOOTH;
        camera.position.set(0, 0, zCurrent + CONST.START_Z);
        const lookX = mouseX * CONST.LOOK_PARALLAX;
        const lookY = mouseY * CONST.LOOK_PARALLAX * 0.4;
        camera.lookAt(lookX, lookY, zCurrent + 10);
        renderer.render(scene, camera);
        setTimeout(tick, 16);
    }

    self.onmessage = async (e) => {
        const msg = e.data || {};
        if(msg.type === 'init'){
            CONST = Object.assign({}, CONST, msg.constants || {});
            SMOOTH = Math.max(0.02, Math.min(0.2, msg.smooth || 0.08));

            canvas = msg.canvas;
            width = msg.width; height = msg.height; dpr = msg.dpr;

            // Prefer explicit context to hint desynchronized
            const gl = canvas.getContext('webgl2', {
                alpha: true,
                antialias: true,
                desynchronized: true,
                premultipliedAlpha: true,
                preserveDrawingBuffer: false
            }) || canvas.getContext('webgl', {
                alpha: true,
                antialias: true,
                desynchronized: true
            });

            renderer = new self.THREE.WebGLRenderer({
                canvas: canvas,
                context: gl,
                alpha: true,
                antialias: true,
                premultipliedAlpha: true,
                powerPreference: 'high-performance'
            });
            renderer.outputColorSpace = self.THREE.SRGBColorSpace;
            renderer.setClearColor(0x000000, 0);

            scene = new self.THREE.Scene();
            scene.fog = new self.THREE.FogExp2(0x000000, 0.025);

            camera = new self.THREE.PerspectiveCamera(
                CONST.CAMERA_FOV,
                width/height,
                0.1,
                CONST.FAR_PAD + CONST.Z_MAX + 100
            );
            camera.position.set(0, 0, CONST.START_Z);
            camera.lookAt(0, 0, CONST.START_Z + 10);

            scene.add(new self.THREE.AmbientLight(0xffffff, 0.85));
            const dir = new self.THREE.DirectionalLight(0xffffff, 0.55);
            dir.position.set(1, 2, 1);
            scene.add(dir);

            planeGeo = new self.THREE.PlaneGeometry(1, 1);
            {
  // Flip UV.y \u0432 \u0432\u043E\u0440\u043A\u0435\u0440\u0435
  const uv = planeGeo.attributes.uv;
  for (let i = 0; i < uv.count; i++) uv.setY(i, 1 - uv.getY(i));
  uv.needsUpdate = true;
}
            maskTex = roundedAlphaTexture(CONST.CORNER_RADIUS_UV, 256);
            

            const leftZ = buildZTrack(CONST.Z_MAX, CONST.Z_MIN_GAP, CONST.Z_EXTRA, Math.random()*CONST.Z_MIN_GAP);
            const rightZ = buildZTrack(CONST.Z_MAX, CONST.Z_MIN_GAP, CONST.Z_EXTRA, Math.random()*CONST.Z_MIN_GAP*0.6);

            const imgs = (msg.images || []).slice();
            // already shuffled by main; still ok if not
            let idx = 0; const next = () => imgs[(idx++) % Math.max(1, imgs.length)];

            await Promise.all([
                placeSide(-1, leftZ, next),
                placeSide(+1, rightZ, next)
            ]);

            resize({width, height, dpr});
            running = true;
            tick();
        }
        else if(msg.type === 'resize'){
            resize(msg);
        }
        else if(msg.type === 'pointer'){
            mouseX = msg.x || 0;
            mouseY = msg.y || 0;
        }
        else if(msg.type === 'progress'){
            targetZ = msg.targetZ || 0;
        }
        else if(msg.type === 'dispose'){
            running = false;
            try {
                meshes.forEach((m)=>{
                    const mat = m.material;
                    if(mat && mat.map) mat.map.dispose && mat.map.dispose();
                    if(mat && mat.alphaMap) mat.alphaMap.dispose && mat.alphaMap.dispose();
                    mat && mat.dispose && mat.dispose();
                    m.geometry && m.geometry.dispose && m.geometry.dispose();
                    scene.remove(m);
                });
                planeGeo && planeGeo.dispose && planeGeo.dispose();
                maskTex && maskTex.dispose && maskTex.dispose();
                renderer && renderer.dispose && renderer.dispose();
            } catch(e){}
        }
    };
    `;
	const blob = new Blob([src], {
		type: "application/javascript",
	});
	return URL.createObjectURL(blob);
}
addPropertyControls(PhotoTunnel, {
	images: {
		type: ControlType.Array,
		title: "Images",
		maxCount: 20,
		control: {
			type: ControlType.Image,
		},
	},
	smooth: {
		type: ControlType.Number,
		title: "Smoothing",
		min: 0.02,
		max: 0.2,
		step: 5e-3,
		defaultValue: 0.08,
	},
});
PhotoTunnel.defaultProps = {
	width: 1200,
	height: 3e3,
	images: [],
	smooth: 0.08,
};

// virtual:photo-tunnel
import { WithFramerBreakpoints } from "unframer";
import { jsx } from "react/jsx-runtime";
var locales = [];
var defaultResponsiveVariants = {};
/** @type {function(Props): any} */
function ComponentWithRoot({ locale, ...rest }) {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"1bd92cedbbf431b3411a7ddd12ea507e929f85a97d28da8179a9646480dcde76"
			}
			locale={locale}
			locales={locales}
		>
			<PhotoTunnel {...rest} />
		</ContextProviders>
	);
}
/**
 * @type {import("unframer").UnframerBreakpoint}
 * Represents a responsive breakpoint for unframer.
 */

/**
 * @typedef VariantsMap
 * Partial record of UnframerBreakpoint to Props.variant, with a mandatory 'base' key.
 * { [key in UnframerBreakpoint]?: Props['variant'] } & { base: Props['variant'] }
 */

/**
 * Renders PhotoTunnelFramerComponent for all breakpoints with a variants map. Variant prop is inferred per breakpoint.
 * @function
 * @param {Omit<Props, 'variant'> & {variants?: VariantsMap}} props
 * @returns {any}
 */
ComponentWithRoot.Responsive = ({ locale = "", ...rest }) => {
	return (
		<ContextProviders
			routes={routes}
			framerSiteId={
				"1bd92cedbbf431b3411a7ddd12ea507e929f85a97d28da8179a9646480dcde76"
			}
			locale={locale}
			locales={locales}
		>
			<WithFramerBreakpoints
				Component={PhotoTunnel}
				variants={defaultResponsiveVariants}
				{...rest}
			/>
		</ContextProviders>
	);
};
Object.assign(ComponentWithRoot, PhotoTunnel);
var photo_tunnel_default = ComponentWithRoot;
export { photo_tunnel_default as default };
