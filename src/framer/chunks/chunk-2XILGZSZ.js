// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 1bd92cedbbf431b3 "Sentinel AI", do not edit manually */
// /:https://framerusercontent.com/modules/2tgtXVGeGeCIhXNGqA0o/WP8u07uOXuonFJIRY7xt/HorizontalTextTube.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useMemo, useRef } from "react";
import { addPropertyControls, ControlType, RenderTarget } from "unframer";
import { useScroll } from "unframer";
var __unframerWindow = typeof window !== "undefined" ? window : void 0;
var URL_THREE = "https://esm.sh/three@0.160.0?bundle";
var ANGLE_FRONT = Math.PI / 2;
var TEX_DPR_CAP = 2;
var MOBILE_MAX = 809;
function HorizontalTextTube(p) {
  const { words = ["Formula 1", "CLAUDE", "MIDJOURNEY", "RUNWAY", "BOTTOM"], font, textColor = "#ffffff", radius = 1.2, span = 0.22, gap = 0.2, widthScale = 1, letterSpacingEm = -0.03, backOpacity = 0.025, speed = 1, inertia = 0.15, texDpr = 1.5, padTopPct = 0, animateOnMobile = false } = p;
  function toCssFontStyle(f) {
    if (!f) return { fontFamily: "Inter", fontWeight: 700, fontStyle: "normal", fontSynthesis: "none" };
    if (typeof f === "string") return { fontFamily: f, fontWeight: 400, fontStyle: "normal", fontSynthesis: "none" };
    const any = f;
    const family = any.family ?? any.fontFamily ?? "Inter";
    const weight = Number(any.weight ?? any.fontWeight ?? 400);
    const styleRaw = (any.style ?? any.fontStyle ?? "normal") + "";
    const fontStyle = styleRaw.toLowerCase().includes("italic") ? "italic" : "normal";
    return { fontFamily: family, fontWeight: weight, fontStyle, fontSynthesis: "none" };
  }
  const fontKey = useMemo(() => {
    if (!font) return "Inter|normal|700";
    if (typeof font === "string") return `${font}|normal|400`;
    const any = font;
    const family = any.family ?? any.fontFamily ?? "Inter";
    const weight = Number(any.weight ?? any.fontWeight ?? 400);
    const styleRaw = String(any.style ?? any.fontStyle ?? "normal");
    const style = styleRaw.toLowerCase().includes("italic") ? "italic" : "normal";
    return `${family}|${style}|${weight}`;
  }, [font]);
  const framerFontStyle = useMemo(() => toCssFontStyle(font), [fontKey]);
  const wrapRef = useRef(null);
  const stickyRef = useRef(null);
  const canvasRef = useRef(null);
  const sentinelRef = useRef(null);
  const loaderRef = useRef(null);
  const resolvedFamilyRef = useRef("Inter");
  const resolvedWeightRef = useRef(700);
  const resolvedStyleRef = useRef("normal");
  const radiusRef = useRef(radius);
  const spanRef = useRef(span);
  const gapRef = useRef(gap);
  const widthScaleRef = useRef(widthScale);
  const backOpacityRef = useRef(backOpacity);
  const speedRef = useRef(speed);
  const inertiaRef = useRef(Math.max(0.01, Math.min(0.5, inertia)));
  const texDprRef = useRef(Math.min(Math.max(1, texDpr), TEX_DPR_CAP));
  const textColorRef = useRef(textColor);
  const letterSpacingRef = useRef(letterSpacingEm);
  const padTopPctRef = useRef(padTopPct);
  const animateOnMobileRef = useRef(animateOnMobile);
  const isMobileRef = useRef(false);
  const isActiveRef = useRef(true);
  const buildingRef = useRef(false);
  const rebuildScheduledRef = useRef(false);
  const rebuildTimeoutRef = useRef(null);
  const runningRef = useRef(false);
  const lastFrameTimeRef = useRef(0);
  const targetFpsRef = useRef(null);
  const ensureLoopRef = useRef(() => {
  });
  function scheduleReflow() {
    for (const e of entriesRef.current) e.reflow();
  }
  function scheduleRebuild() {
    if (buildingRef.current) return;
    if (rebuildTimeoutRef.current) return;
    rebuildTimeoutRef.current = __unframerWindow.setTimeout(() => {
      rebuildScheduledRef.current = true;
      rebuildTimeoutRef.current = null;
      ensureLoopRef.current?.();
    }, 200);
  }
  useEffect(() => {
    spanRef.current = span;
    scheduleRebuild();
  }, [span]);
  useEffect(() => {
    gapRef.current = gap;
    scheduleReflow();
  }, [gap]);
  useEffect(() => {
    widthScaleRef.current = widthScale;
    scheduleRebuild();
  }, [widthScale]);
  useEffect(() => {
    backOpacityRef.current = backOpacity;
    scheduleReflow();
  }, [backOpacity]);
  useEffect(() => {
    speedRef.current = speed;
  }, [speed]);
  useEffect(() => {
    inertiaRef.current = Math.max(0.01, Math.min(0.5, inertia));
  }, [inertia]);
  useEffect(() => {
    texDprRef.current = Math.min(Math.max(1, texDpr), TEX_DPR_CAP);
    scheduleRebuild();
  }, [texDpr]);
  useEffect(() => {
    textColorRef.current = textColor;
    scheduleReflow();
  }, [textColor]);
  useEffect(() => {
    letterSpacingRef.current = letterSpacingEm;
    scheduleRebuild();
  }, [letterSpacingEm]);
  useEffect(() => {
    padTopPctRef.current = Math.max(0, Math.min(100, padTopPct));
    repositionNow();
  }, [padTopPct]);
  useEffect(() => {
    animateOnMobileRef.current = !!animateOnMobile;
  }, [animateOnMobile]);
  useEffect(() => {
    scheduleRebuild();
  }, [words]);
  useEffect(() => {
    radiusRef.current = radius;
    scheduleReflow();
  }, [radius]);
  const wrapTarget = useRef(null);
  const { scrollYProgress } = useScroll({ target: wrapRef, offset: ["start start", "end start"] });
  const tTargetRef = useRef(0);
  const tCurrentRef = useRef(0);
  const lastScrollTimeRef = useRef(0);
  useEffect(() => {
    const unsub = scrollYProgress.on("change", (v) => {
      const now = performance.now();
      if (now - lastScrollTimeRef.current < 16) return;
      lastScrollTimeRef.current = now;
      tTargetRef.current = Math.max(0, Math.min(1, v));
      ensureLoopRef.current?.();
    });
    return () => unsub();
  }, [scrollYProgress]);
  const THREERef = useRef(null);
  const rendererRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rootRef = useRef(null);
  const entriesRef = useRef([]);
  const texCacheRef = useRef(/* @__PURE__ */ new Map());
  useEffect(() => {
    const node = wrapRef.current;
    if (!node) return;
    const io = new IntersectionObserver((ents) => {
      isActiveRef.current = !!ents[0]?.isIntersecting;
      if (isActiveRef.current) ensureLoopRef.current?.();
    }, { root: null, threshold: 0.01 });
    io.observe(node);
    return () => io.disconnect();
  }, []);
  function firstFamilyToken(cssFontFamily) {
    const parts = cssFontFamily.split(",").map((s) => s.trim().replace(/^['"]|['"]$/g, ""));
    return parts[0] || "Inter";
  }
  async function resolveAndLoadFont() {
    if (!sentinelRef.current) {
      const span2 = document.createElement("span");
      span2.textContent = "A\u0436QW07";
      span2.style.position = "fixed";
      span2.style.left = "-99999px";
      span2.style.top = "0";
      span2.style.opacity = "0";
      span2.style.pointerEvents = "none";
      span2.style.whiteSpace = "nowrap";
      document.body.appendChild(span2);
      sentinelRef.current = span2;
    }
    const s = sentinelRef.current;
    s.removeAttribute("style");
    s.style.position = "fixed";
    s.style.left = "-99999px";
    s.style.top = "0";
    s.style.opacity = "0";
    s.style.pointerEvents = "none";
    s.style.whiteSpace = "nowrap";
    s.style.fontSynthesis = "none";
    Object.assign(s.style, framerFontStyle);
    const cs = getComputedStyle(s);
    const fam = firstFamilyToken(cs.fontFamily || "Inter");
    const st = cs.fontStyle || "normal";
    const wStr = cs.fontWeight || "400";
    const wNum = wStr === "normal" ? 400 : wStr === "bold" ? 700 : parseInt(wStr, 10) || 700;
    resolvedFamilyRef.current = fam;
    resolvedStyleRef.current = st;
    resolvedWeightRef.current = wNum;
    const fontsAny = document.fonts;
    try {
      if (fontsAny?.ready) {
        await Promise.race([fontsAny.ready, new Promise((r) => setTimeout(() => r(), 800))]);
      }
    } catch {
    }
    await new Promise((r) => requestAnimationFrame(() => requestAnimationFrame(r)));
  }
  function canvasFont(sizePx) {
    const fam = resolvedFamilyRef.current.replace(/['"]/g, "");
    const w = resolvedWeightRef.current;
    const st = resolvedStyleRef.current;
    return `${st} ${w} ${sizePx}px "${fam}", system-ui, -apple-system, "Segoe UI", Roboto, Arial`;
  }
  function drawWithTracking(ctx, text, cx, cy, lsPx) {
    ctx.textAlign = "left";
    const widths = [...text].map((ch) => ctx.measureText(ch).width);
    const total = widths.reduce((a, b) => a + b, 0) + Math.max(0, text.length - 1) * lsPx;
    let x = cx - total / 2;
    for (let i = 0; i < text.length; i++) {
      ctx.fillText(text[i], x, cy);
      x += widths[i] + lsPx;
    }
    return total;
  }
  function measureWithTracking(ctx, text, lsPx) {
    const widths = [...text].map((ch) => ctx.measureText(ch).width);
    return widths.reduce((a, b) => a + b, 0) + Math.max(0, text.length - 1) * lsPx;
  }
  function cacheKey(text, colorHex, fs, lsPx, family, weight, style) {
    return `${text}|${colorHex}|fs:${fs}|ls:${lsPx}|${family}|${weight}|${style}`;
  }
  async function makeWordTexture(THREE, text, colorHex) {
    await resolveAndLoadFont();
    const dprSys = __unframerWindow.devicePixelRatio || 1;
    const cap = isMobileRef.current ? 1.5 : TEX_DPR_CAP;
    const scale = Math.min(texDprRef.current, dprSys, cap);
    const baseH = isMobileRef.current ? 768 : 1024;
    const H = Math.round(baseH * scale);
    const fs = Math.max(10, Math.round(H * 0.5));
    const lsPx = letterSpacingRef.current * fs;
    const fam = resolvedFamilyRef.current.replace(/['"]/g, "");
    const w = resolvedWeightRef.current;
    const st = resolvedStyleRef.current;
    const key = cacheKey(text, colorHex, fs, lsPx, fam, w, st);
    const cached = texCacheRef.current.get(key);
    if (cached) return cached;
    const probe = document.createElement("canvas").getContext("2d");
    probe.textBaseline = "middle";
    probe.fontKerning = "normal";
    probe.font = canvasFont(fs);
    const pad = Math.round(48 * scale);
    const contentW = measureWithTracking(probe, text, lsPx);
    const W = Math.max(256, Math.ceil(contentW + pad * 2));
    const cnv = document.createElement("canvas");
    cnv.width = W;
    cnv.height = H;
    const ctx = cnv.getContext("2d");
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = colorHex;
    ctx.textBaseline = "middle";
    ctx.imageSmoothingEnabled = false;
    ctx.fontKerning = "normal";
    ctx.font = canvasFont(fs);
    drawWithTracking(ctx, text, W / 2, H / 2, lsPx);
    const tex = new THREE.CanvasTexture(cnv);
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.premultiplyAlpha = true;
    tex.generateMipmaps = true;
    tex.minFilter = THREE.LinearMipmapLinearFilter;
    tex.magFilter = THREE.LinearFilter;
    tex.anisotropy = Math.min(isMobileRef.current ? 2 : 4, rendererRef.current?.capabilities?.getMaxAnisotropy?.() || 1);
    tex.needsUpdate = true;
    const textAspect = contentW / fs;
    const result = { tex, textAspect, texW: W, texH: H };
    texCacheRef.current.set(key, result);
    return result;
  }
  const vert = (
    /* glsl */
    `
    precision highp float;
    varying vec2 vUv;
    varying vec3 vWorldPos;
    varying vec3 vWorldNormal;
    uniform float radius, worldW, angularSpan, centerPhi;
    void main(){
      vUv = uv;
      float xWorld = (uv.x - 0.5) * worldW;
      float phi = centerPhi - (uv.y - 0.5) * angularSpan;
      vec3 pos = vec3(xWorld, radius * cos(phi), radius * sin(phi));
      vec3 nor = vec3(0.0, cos(phi), sin(phi));
      vWorldPos = (modelMatrix * vec4(pos, 1.0)).xyz;
      vWorldNormal = normalize(mat3(modelMatrix) * nor);
      gl_Position = projectionMatrix * viewMatrix * vec4(vWorldPos, 1.0);
    }`
  );
  const frag = (
    /* glsl */
    `
    precision highp float;
    varying vec2 vUv;
    varying vec3 vWorldPos, vWorldNormal;
    uniform sampler2D mapTex;
    uniform float backOpacity;
    uniform vec2 texel;
    uniform vec3 uTextColor;
    float A(vec2 uv){ return texture2D(mapTex, uv).a; }
    void main(){
      vec2 uv = vUv;
      // Minor alpha smoothing using neighbor taps to fight hard pixel edges
      float a = ( A(uv)*4.0 + A(uv+vec2(texel.x,0.0)) + A(uv-vec2(texel.x,0.0)) ) / 6.0;
      a = smoothstep(0.06, 0.35, a);
      if(a <= 0.0) discard;
      vec3 V = normalize(cameraPosition - vWorldPos);
      float facing = dot(normalize(vWorldNormal), V);
      float opa = facing >= 0.0 ? 1.0 : backOpacity;
      gl_FragColor = vec4(uTextColor, a * opa);
    }`
  );
  async function makeHorizontalWord(THREE, text, colorHex) {
    const info = await makeWordTexture(THREE, text, colorHex);
    const worldW = info.textAspect * spanRef.current * Math.max(0.1, widthScaleRef.current);
    const segW = isMobileRef.current ? 8 : 16;
    const segH = isMobileRef.current ? 32 : 64;
    const geo = new THREE.PlaneGeometry(1, 1, segW, segH);
    const mat = new THREE.ShaderMaterial({ uniforms: { mapTex: { value: info.tex }, radius: { value: radiusRef.current }, worldW: { value: worldW }, angularSpan: { value: spanRef.current / radiusRef.current }, centerPhi: { value: ANGLE_FRONT }, backOpacity: { value: backOpacityRef.current }, texel: { value: new THREE.Vector2(1 / info.texW, 1 / info.texH) }, uTextColor: { value: new THREE.Color(colorHex) } }, vertexShader: vert, fragmentShader: frag, transparent: true, side: THREE.DoubleSide, depthTest: true, depthWrite: false, dithering: false });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.frustumCulled = false;
    return { mesh, mat, tex: info.tex, textAspect: info.textAspect, setCenter: (phi) => {
      mat.uniforms.centerPhi.value = phi;
    }, reflow: () => {
      mat.uniforms.radius.value = radiusRef.current;
      mat.uniforms.worldW.value = mesh.userData.textAspect * spanRef.current * Math.max(0.1, widthScaleRef.current);
      mat.uniforms.angularSpan.value = spanRef.current / radiusRef.current;
      mat.uniforms.backOpacity.value = backOpacityRef.current;
      mat.uniforms.uTextColor.value.set(textColorRef.current);
      mat.needsUpdate = true;
    }, dispose: () => {
      info.tex.dispose?.();
      geo.dispose?.();
      mat.dispose?.();
    } };
  }
  async function rebuildInPlace() {
    if (!rootRef.current || !THREERef.current) return;
    if (buildingRef.current) return;
    buildingRef.current = true;
    try {
      const THREE = THREERef.current;
      const list = [...words || []].reverse().map((s) => (s ?? "").trim()).filter(Boolean);
      const infos = await Promise.all(list.map((w) => makeWordTexture(THREE, w, textColorRef.current)));
      const minLen = Math.min(entriesRef.current.length, infos.length);
      for (let i = 0; i < minLen; i++) {
        const entry = entriesRef.current[i];
        const info = infos[i];
        entry.mesh.userData.textAspect = info.textAspect;
        const oldTex = entry.mat.uniforms.mapTex.value;
        entry.mat.uniforms.mapTex.value = info.tex;
        entry.mat.uniforms.texel.value.set(1 / info.texW, 1 / info.texH);
        entry.tex = info.tex;
        entry.textAspect = info.textAspect;
        entry.mat.uniforms.worldW.value = info.textAspect * spanRef.current * Math.max(0.1, widthScaleRef.current);
        oldTex?.dispose?.();
        entry.mat.needsUpdate = true;
      }
      if (infos.length > entriesRef.current.length) {
        for (let i = entriesRef.current.length; i < infos.length; i++) {
          const extra = await makeHorizontalWord(THREE, list[i], textColorRef.current);
          extra.mesh.userData.textAspect = extra.textAspect;
          rootRef.current.add(extra.mesh);
          entriesRef.current.push(extra);
        }
      }
      if (infos.length < entriesRef.current.length) {
        for (let i = entriesRef.current.length - 1; i >= infos.length; i--) {
          const e = entriesRef.current[i];
          rootRef.current.remove(e.mesh);
          e.dispose();
          entriesRef.current.pop();
        }
      }
    } finally {
      buildingRef.current = false;
    }
  }
  function repositionNow() {
    const sticky = stickyRef.current;
    const root = rootRef.current;
    const camera = cameraRef.current;
    const renderer = rendererRef.current;
    if (!sticky || !root || !camera || !renderer) return;
    const r = sticky.getBoundingClientRect();
    const sys = __unframerWindow.devicePixelRatio || 1;
    let finalDPR = Math.min(TEX_DPR_CAP, Math.max(texDprRef.current, sys));
    if (isMobileRef.current) finalDPR = Math.min(finalDPR, 1.5);
    renderer.setPixelRatio(finalDPR);
    renderer.setSize(r.width, r.height, false);
    camera.aspect = Math.max(1e-6, r.width / r.height);
    camera.updateProjectionMatrix();
    const vFOV = camera.fov * Math.PI / 180;
    const worldHalfH = Math.tan(vFOV / 2) * camera.position.z;
    const unitsPerPx = worldHalfH * 2 / r.height;
    const padTopPx = Math.max(0, Math.min(100, padTopPctRef.current)) / 100 * r.height;
    root.position.x = 0;
    root.position.y = worldHalfH - padTopPx * unitsPerPx;
    root.updateMatrix();
    sceneRef.current?.updateMatrixWorld(true);
  }
  useEffect(() => {
    let mounted = true;
    let raf = null;
    let ro = null;
    const ensureLoop = () => {
      if (!mounted) return;
      if (runningRef.current) return;
      runningRef.current = true;
      raf = requestAnimationFrame(animate);
    };
    ensureLoopRef.current = ensureLoop;
    const init = async () => {
      const sticky = stickyRef.current;
      const canvas = canvasRef.current;
      if (!sticky || !canvas) return;
      const isMobile = __unframerWindow.matchMedia?.(`(max-width: ${MOBILE_MAX}px)`)?.matches === true;
      isMobileRef.current = isMobile;
      canvas.style.willChange = "transform";
      if (!THREERef.current) THREERef.current = await import(URL_THREE);
      const THREE = THREERef.current;
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, powerPreference: isMobile ? "low-power" : "high-performance", premultipliedAlpha: true });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapped = false;
      renderer.sortObjects = false;
      renderer.shadowMap.enabled = false;
      rendererRef.current = renderer;
      const scene = new THREE.Scene();
      scene.matrixAutoUpdate = false;
      sceneRef.current = scene;
      const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
      camera.position.set(0, 0, 6);
      camera.lookAt(0, 0, 0);
      cameraRef.current = camera;
      const root = new THREE.Group();
      root.matrixAutoUpdate = false;
      scene.add(root);
      rootRef.current = root;
      const applySize = () => {
        repositionNow();
        if (isMobileRef.current && !animateOnMobileRef.current && rendererRef.current && sceneRef.current && cameraRef.current) {
          rendererRef.current.render(sceneRef.current, cameraRef.current);
        }
      };
      applySize();
      ro = new ResizeObserver(applySize);
      ro.observe(sticky);
      await rebuildInPlace();
      if (!mounted) return;
      if (isMobile && animateOnMobileRef.current) {
        targetFpsRef.current = 80;
      } else {
        targetFpsRef.current = null;
      }
      if (isMobile && !animateOnMobileRef.current) {
        if (rendererRef.current && sceneRef.current && cameraRef.current) {
          rendererRef.current.render(sceneRef.current, cameraRef.current);
        }
        return;
      }
      ensureLoop();
    };
    const animate = () => {
      if (!mounted) return;
      if (!rendererRef.current || !sceneRef.current || !cameraRef.current) {
        runningRef.current = false;
        return;
      }
      if (!isActiveRef.current) {
        runningRef.current = false;
        return;
      }
      const fps = targetFpsRef.current;
      if (fps) {
        const now = performance.now();
        const minDt = 1e3 / fps;
        if (now - lastFrameTimeRef.current < minDt) {
          raf = requestAnimationFrame(animate);
          return;
        }
        lastFrameTimeRef.current = now;
      }
      const spd = Math.max(0.01, speedRef.current);
      const inert = inertiaRef.current;
      const target = Math.min(1, Math.max(0, tTargetRef.current * spd));
      const prev = tCurrentRef.current;
      tCurrentRef.current += (target - tCurrentRef.current) * inert;
      const moved = Math.abs(tCurrentRef.current - prev) > 1e-5 || rebuildScheduledRef.current;
      if (rebuildScheduledRef.current) {
        rebuildScheduledRef.current = false;
        void rebuildInPlace();
      }
      if (moved) {
        const sp = spanRef.current;
        const rad = radiusRef.current;
        const gp = gapRef.current;
        const angSpan = sp / rad;
        const step = angSpan + gp / rad;
        const peek = angSpan * 0.52;
        const startBase = ANGLE_FRONT + Math.PI + peek;
        const endBase = startBase - Math.PI * 2;
        const base = startBase + tCurrentRef.current * (endBase - startBase);
        for (let i = 0; i < entriesRef.current.length; i++) {
          entriesRef.current[i].setCenter(base - i * step);
        }
        rendererRef.current.render(sceneRef.current, cameraRef.current);
        raf = requestAnimationFrame(animate);
        return;
      }
      runningRef.current = false;
    };
    init();
    return () => {
      mounted = false;
      if (raf != null) cancelAnimationFrame(raf);
      if (ro) ro.disconnect();
      for (const e of entriesRef.current) e.dispose();
      entriesRef.current = [];
      texCacheRef.current.forEach((v) => v.tex.dispose?.());
      texCacheRef.current.clear();
      rendererRef.current?.dispose?.();
      rendererRef.current = null;
      sceneRef.current = null;
      cameraRef.current = null;
      rootRef.current = null;
      sentinelRef.current?.remove();
      sentinelRef.current = null;
      if (rebuildTimeoutRef.current) {
        clearTimeout(rebuildTimeoutRef.current);
      }
    };
  }, []);
  useEffect(() => {
    const wrap = wrapRef.current;
    if (wrap) Object.assign(wrap.style, framerFontStyle);
    if (RenderTarget.current() !== RenderTarget.canvas) {
      scheduleRebuild();
      return;
    }
    const el = loaderRef.current;
    if (!el) {
      scheduleRebuild();
      return;
    }
    const fontsAny = document.fonts;
    if (fontsAny?.ready) {
      fontsAny.ready.then(() => {
        requestAnimationFrame(() => scheduleRebuild());
      });
      setTimeout(() => scheduleRebuild(), 800);
    } else {
      scheduleRebuild();
    }
  }, [fontKey]);
  return /* @__PURE__ */ _jsxs("div", { ref: wrapRef, "data-font-key": fontKey, style: { position: "relative", width: "100%", height: "100%", overflow: "visible", background: "transparent", ...framerFontStyle }, children: [/* @__PURE__ */ _jsx("span", { ref: loaderRef, "aria-hidden": "true", style: { position: "absolute", opacity: 0, pointerEvents: "none", whiteSpace: "nowrap", ...framerFontStyle }, children: "Aa\u0411\u0431Wwmn\u20141234567890" }, fontKey), /* @__PURE__ */ _jsx("div", { ref: stickyRef, style: { position: "sticky", top: 0, height: "100vh", width: "100%", pointerEvents: "none", display: "grid", justifyItems: "center", alignItems: "start" }, children: /* @__PURE__ */ _jsx("canvas", { ref: canvasRef, style: { width: "100%", height: "100%", display: "block" } }) })] });
}
addPropertyControls(HorizontalTextTube, { words: { type: ControlType.Array, title: "Words (TOP\u2192BOTTOM)", propertyControl: { type: ControlType.String, title: "Word" }, defaultValue: ["OPENAI", "CLAUDE", "MIDJOURNEY", "RUNWAY", "BOTTOM"] }, font: { type: ControlType.Font, title: "Font", defaultValue: { family: "Inter", style: "Regular", weight: 700 } }, textColor: { type: ControlType.Color, title: "Text", defaultValue: "#ffffff" }, span: { type: ControlType.Number, title: "Font Size", min: 0.06, max: 1, step: 0.01, defaultValue: 0.22 }, radius: { type: ControlType.Number, title: "Radius", min: 0.6, max: 3, step: 0.01, defaultValue: 1.2 }, gap: { type: ControlType.Number, title: "Line Gap", min: -1, max: 3, step: 0.01, defaultValue: 0.2 }, widthScale: { type: ControlType.Number, title: "Word Width \xD7", min: 0.2, max: 2, step: 0.01, defaultValue: 1 }, letterSpacingEm: { type: ControlType.Number, title: "Tracking (em)", min: -0.12, max: 0.25, step: 5e-3, defaultValue: -0.03 }, backOpacity: { type: ControlType.Number, title: "Back \u03B1", min: 0, max: 0.5, step: 1e-3, defaultValue: 0.025 }, speed: { type: ControlType.Number, title: "Scroll Speed \xD7", min: 0.5, max: 3, step: 0.01, defaultValue: 1 }, inertia: { type: ControlType.Number, title: "Inertia", min: 0.01, max: 0.5, step: 0.01, defaultValue: 0.15 }, texDpr: { type: ControlType.Number, title: "Render DPR (min)", min: 1, max: 2, step: 0.05, defaultValue: 1.5, displayStepper: true }, padTopPct: { type: ControlType.Number, title: "Padding Top (%)", min: 0, max: 100, step: 1, defaultValue: 0, displayStepper: true }, animateOnMobile: { type: ControlType.Boolean, title: "Mobile: Animate", defaultValue: false } });

export {
  HorizontalTextTube
};
