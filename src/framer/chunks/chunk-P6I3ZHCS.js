// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 1bd92cedbbf431b3 "Sentinel AI", do not edit manually */
// /:https://framerusercontent.com/modules/kPdpK9eqXsaTmEUxJjxO/WYWvAAvLfjnBSerBRIZQ/RippleSphere.js
import { jsx as _jsx } from "react/jsx-runtime";
import * as React from "react";
import { addPropertyControls, ControlType, RenderTarget } from "unframer";
import * as THREE from "three";
var __unframerWindow = typeof window !== "undefined" ? window : void 0;
var FREQ = 1;
var SEG_W = 64;
var SEG_H = 32;
var EDGE_SOFTEN = 0;
var DPR_CAP = 1;
var WORKER_TIMEOUT = 3e3;
function RippleSphere(props) {
  const isEditor = RenderTarget.current() === RenderTarget.canvas;
  if (isEditor) return /* @__PURE__ */ _jsx(EditorMode, { textureURL: props.textureURL });
  return /* @__PURE__ */ _jsx(BrowserMode, { ...props });
}
function EditorMode({ textureURL }) {
  const hostRef = React.useRef(null);
  React.useEffect(() => {
    const host = hostRef.current;
    if (!host) return;
    host.innerHTML = "";
    const img = document.createElement("img");
    img.style.width = "100%";
    img.style.height = "100%";
    img.style.objectFit = "cover";
    img.style.display = "block";
    img.style.background = "transparent";
    host.appendChild(img);
    const updateTexture = () => {
      if (textureURL) {
        const bust = (textureURL.includes("?") ? "&" : "?") + "ts=" + Date.now();
        img.src = textureURL + bust;
      } else {
        img.src = "";
      }
    };
    updateTexture();
    return () => {
      if (img.parentNode) img.parentNode.removeChild(img);
    };
  }, [textureURL]);
  return /* @__PURE__ */ _jsx("div", { ref: hostRef, style: {
    width: "100%",
    height: "100%",
    display: "block",
    background: "transparent",
    // Helps layout/paint isolation in Framer
    contentVisibility: "auto",
    contain: "layout paint size"
  } });
}
function BrowserMode(props) {
  const { textureURL = "", rotationSpeed = -0.6, deformSpeed = 0.28, zoom = 3.2, stopInEditor = true, amplitude = 0.66, ripK = 8.7 } = props;
  const hostRef = React.useRef(null);
  const canvasRef = React.useRef(null);
  const rotRef = React.useRef(rotationSpeed);
  const speedRef = React.useRef(deformSpeed);
  const zoomRef = React.useRef(zoom);
  const ampRef = React.useRef(amplitude);
  const ripRef = React.useRef(ripK);
  React.useEffect(() => {
    rotRef.current = rotationSpeed;
  }, [rotationSpeed]);
  React.useEffect(() => {
    speedRef.current = deformSpeed;
  }, [deformSpeed]);
  React.useEffect(() => {
    zoomRef.current = zoom;
  }, [zoom]);
  React.useEffect(() => {
    ampRef.current = amplitude;
  }, [amplitude]);
  React.useEffect(() => {
    ripRef.current = ripK;
  }, [ripK]);
  const workerRef = React.useRef(null);
  const workerURLRef = React.useRef(null);
  const roRef = React.useRef(null);
  const fallbackRef = React.useRef(null);
  const isMountedRef = React.useRef(false);
  const attemptIdRef = React.useRef(0);
  const visibilityPausedRef = React.useRef(false);
  const intersectPausedRef = React.useRef(false);
  React.useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const ensureWorkerURL = React.useCallback(() => {
    if (workerURLRef.current) return workerURLRef.current;
    const workerFn = function() {
      importScripts("https://unpkg.com/three@0.160.0/build/three.min.js");
      const THREE2 = self.THREE;
      let canvas = null;
      let renderer = null;
      let scene = null;
      let camera = null;
      let mesh = null;
      let mat = null;
      let geom = null;
      let uniforms = null;
      let currentTexture = null;
      let rotSpeed = -0.6;
      let deformSpeed2 = 0.28;
      let zoom2 = 3.2;
      let amplitude2 = 0.66;
      let ripK2 = 8.7;
      const FREQ2 = 1;
      const SEG_W2 = 64;
      const SEG_H2 = 32;
      const EDGE_SOFTEN2 = 0;
      let paused = false;
      let running = false;
      let lastTime = 0;
      let loadId = 0;
      let fpsMs = 8;
      const NOISE = `
float hash(vec3 p) {
  p = fract(p * 0.3183099 + .1);
  p *= 10.0;
  return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
}
float noise(vec3 x) {
  vec3 i = floor(x);
  vec3 f = fract(x);
  f = f * f * (3.0 - 2.0 * f);
  return mix(
    mix(mix(hash(i + vec3(0,0,0)), hash(i + vec3(1,0,0)), f.x),
        mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
    mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
        mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y),
    f.z);
}`;
      const VERT_PATCH = `
vec3 p = position;
vec3 n = normal;
float baseR = length(p);
vec3 dirN = p / baseR;

float edgeMask = 1.0;

float u = 0.5 + 0.5 * atan(dirN.z, dirN.x) / 3.14159265359;
u = u - floor(u);
float v = 0.5 - asin(dirN.y) / 3.14159265359;

float sphericalCoord = u * 6.28318530718 * 0.5 + v * 3.14159265359;

float phaseNoise = 0.08 * noise(dirN * uFreq * 0.8);

float band = sin(uRipK * (sphericalCoord + phaseNoise + uTime * uSpeed));

vec3 transformed = dirN * (baseR * (1.0 + (uAmp * edgeMask) * band));
`;
      function loop() {
        if (!running || !renderer || !camera || !scene || !mesh || !uniforms) return;
        const now = performance.now();
        const dt = Math.max(0, Math.min((now - lastTime) / 1e3, 0.1));
        lastTime = now;
        camera.position.z = Math.max(0.2, zoom2);
        if (!paused) {
          uniforms.uTime.value += dt;
          if (rotSpeed !== 0) mesh.rotation.y += rotSpeed * dt;
          uniforms.uAmp.value = amplitude2;
          uniforms.uRipK.value = ripK2;
          uniforms.uSpeed.value = deformSpeed2;
        }
        renderer.render(scene, camera);
        setTimeout(loop, paused ? 250 : fpsMs);
      }
      async function loadTexture(url2) {
        if (!url2 || !renderer || !mat) return;
        const id = ++loadId;
        try {
          const finalURL = url2 + (url2.includes("?") ? "&" : "?") + "ts=" + Date.now();
          const res = await fetch(finalURL, { mode: "cors" });
          const blob2 = await res.blob();
          const bmp = await createImageBitmap(blob2, { imageOrientation: "none", premultiplyAlpha: "none" });
          const tex = new THREE2.Texture(bmp);
          tex.colorSpace = THREE2.SRGBColorSpace;
          tex.anisotropy = Math.min(2, renderer.capabilities.getMaxAnisotropy());
          tex.needsUpdate = true;
          if (id !== loadId) {
            tex.dispose();
            return;
          }
          const prev = currentTexture;
          currentTexture = tex;
          mat.map = tex;
          mat.needsUpdate = true;
          if (prev) prev.dispose();
        } catch (e) {
          self.postMessage({ type: "warn", message: "texture-load-failed" });
        }
      }
      self.onmessage = (ev) => {
        const msg = ev.data;
        if (msg && msg.type === "init") {
          try {
            canvas = msg.canvas;
            const width = Math.max(1, msg.width);
            const height = Math.max(1, msg.height);
            const dpr = msg.dpr || 1;
            const gl = canvas.getContext("webgl2", { antialias: false, alpha: true, premultipliedAlpha: true, preserveDrawingBuffer: false, powerPreference: "high-performance" }) || canvas.getContext("webgl", { antialias: false, alpha: true });
            if (!gl) {
              self.postMessage({ type: "fatal", message: "no-webgl-context" });
              return;
            }
            renderer = new THREE2.WebGLRenderer({ canvas, context: gl, alpha: true, antialias: false, powerPreference: "high-performance" });
            renderer.outputColorSpace = THREE2.SRGBColorSpace;
            renderer.toneMapping = THREE2.NoToneMapping;
            renderer.setClearColor(0, 0);
            renderer.setPixelRatio(dpr);
            renderer.setSize(width, height, false);
            scene = new THREE2.Scene();
            camera = new THREE2.PerspectiveCamera(45, width / height, 0.1, 100);
            camera.position.set(0, 0, Math.max(0.2, msg.props.zoom));
            scene.add(new THREE2.HemisphereLight(16777215, 2236979, 1.8));
            const key = new THREE2.DirectionalLight(16777215, 2.5);
            key.position.set(2.5, 3, 3.5);
            scene.add(key);
            geom = new THREE2.SphereGeometry(1, SEG_W2, SEG_H2);
            uniforms = { uTime: { value: 0 }, uAmp: { value: msg.props.amplitude }, uFreq: { value: FREQ2 }, uSpeed: { value: msg.props.deformSpeed }, uRipK: { value: msg.props.ripK }, uEdgeSoften: { value: EDGE_SOFTEN2 } };
            mat = new THREE2.MeshStandardMaterial({ color: 16777215, roughness: 0.6, metalness: 0 });
            mat.onBeforeCompile = (shader) => {
              Object.assign(shader.uniforms, uniforms);
              shader.vertexShader = shader.vertexShader.replace("#include <common>", "#include <common>\nuniform float uTime,uAmp,uFreq,uSpeed,uRipK,uEdgeSoften;\n" + NOISE);
              shader.vertexShader = shader.vertexShader.replace("#include <begin_vertex>", VERT_PATCH);
            };
            mat.needsUpdate = true;
            mesh = new THREE2.Mesh(geom, mat);
            scene.add(mesh);
            rotSpeed = msg.props.rotationSpeed;
            deformSpeed2 = msg.props.deformSpeed;
            zoom2 = msg.props.zoom;
            amplitude2 = msg.props.amplitude;
            ripK2 = msg.props.ripK;
            paused = !!msg.props.paused;
            if (typeof msg.props.fps === "number") {
              const f = Math.max(1, msg.props.fps);
              fpsMs = Math.max(4, Math.floor(1e3 / f));
            }
            if (msg.props.textureURL) loadTexture(msg.props.textureURL);
            running = true;
            lastTime = performance.now();
            renderer.render(scene, camera);
            self.postMessage({ type: "ready" });
            setTimeout(loop, paused ? 250 : fpsMs);
          } catch (e) {
            self.postMessage({ type: "fatal", message: "init-failed" });
          }
        } else if (msg && msg.type === "resize") {
          if (!renderer || !camera) return;
          renderer.setPixelRatio(msg.dpr || 1);
          const w = Math.max(1, msg.width);
          const h = Math.max(1, msg.height);
          renderer.setSize(w, h, false);
          camera.aspect = Math.max(1e-6, w / Math.max(1, h));
          camera.updateProjectionMatrix();
          renderer.render(scene, camera);
        } else if (msg && msg.type === "props") {
          const p = msg.props || {};
          if ("rotationSpeed" in p) rotSpeed = p.rotationSpeed;
          if ("deformSpeed" in p) {
            deformSpeed2 = p.deformSpeed;
            if (uniforms) uniforms.uSpeed.value = deformSpeed2;
          }
          if ("zoom" in p) zoom2 = p.zoom;
          if ("amplitude" in p) {
            amplitude2 = p.amplitude;
            if (uniforms) uniforms.uAmp.value = amplitude2;
          }
          if ("ripK" in p) {
            ripK2 = p.ripK;
            if (uniforms) uniforms.uRipK.value = ripK2;
          }
          if ("paused" in p) paused = !!p.paused;
          if ("fps" in p) {
            const f = Math.max(1, p.fps);
            fpsMs = Math.max(4, Math.floor(1e3 / f));
          }
          if (p.textureURL) loadTexture(p.textureURL);
          if (renderer && camera) renderer.render(scene, camera);
        } else if (msg && msg.type === "dispose") {
          running = false;
          try {
            if (currentTexture) currentTexture.dispose();
            if (geom) geom.dispose();
            if (mat && mat.dispose) mat.dispose();
            if (renderer && renderer.dispose) renderer.dispose();
          } catch (e) {
          }
          self.close();
        }
      };
    };
    const src = `(${workerFn.toString()})();`;
    const blob = new Blob([src], { type: "application/javascript" });
    const url = URL.createObjectURL(blob);
    workerURLRef.current = url;
    return url;
  }, []);
  function postProps(p) {
    const w = workerRef.current;
    if (w) w.postMessage({ type: "props", props: p });
    else if (fallbackRef.current) {
      if ("rotationSpeed" in p) rotRef.current = p.rotationSpeed;
      if ("deformSpeed" in p) speedRef.current = p.deformSpeed;
      if ("zoom" in p) zoomRef.current = p.zoom;
      if ("amplitude" in p) ampRef.current = p.amplitude;
      if ("ripK" in p) ripRef.current = p.ripK;
      if ("paused" in p) fallbackRef.current.setPaused?.(!!p.paused);
      if ("fps" in p) fallbackRef.current.setFps?.(p.fps);
      if ("textureURL" in p) fallbackRef.current.swapTexture?.(p.textureURL);
    }
  }
  React.useEffect(() => {
    const host = hostRef.current;
    if (!host) return;
    const attemptId = ++attemptIdRef.current;
    let active = true;
    const canvas = document.createElement("canvas");
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    canvas.style.display = "block";
    canvas.style.background = "transparent";
    host.appendChild(canvas);
    canvasRef.current = canvas;
    const cleanup = () => {
      active = false;
      if (workerRef.current) {
        try {
          workerRef.current.postMessage({ type: "dispose" });
          workerRef.current.terminate();
        } catch {
        }
        workerRef.current = null;
      }
      if (roRef.current) {
        roRef.current.disconnect();
        roRef.current = null;
      }
      if (workerURLRef.current) {
        try {
          URL.revokeObjectURL(workerURLRef.current);
        } catch {
        }
        workerURLRef.current = null;
      }
    };
    const startFallbackNow = () => {
      if (!active || attemptId !== attemptIdRef.current) return;
      cleanup();
      const newCanvas = document.createElement("canvas");
      newCanvas.style.width = "100%";
      newCanvas.style.height = "100%";
      newCanvas.style.display = "block";
      host.innerHTML = "";
      host.appendChild(newCanvas);
      canvasRef.current = newCanvas;
      startFallbackMain(newCanvas);
      fallbackRef.current?.setFps?.(30);
      fallbackRef.current?.setPaused?.(false);
    };
    const hostEl = hostRef.current;
    const io = new IntersectionObserver((entries) => {
      const e = entries[0];
      const visible = !!e && e.isIntersecting && e.intersectionRatio > 0.1;
      intersectPausedRef.current = !visible;
      postProps({ paused: !visible, fps: visible ? 30 : 12 });
    }, { threshold: [0, 0.1, 0.5, 1] });
    io.observe(hostEl);
    const onVis = () => {
      const hidden = document.hidden;
      visibilityPausedRef.current = hidden;
      postProps({ paused: hidden, fps: hidden ? 8 : 30 });
    };
    document.addEventListener("visibilitychange", onVis);
    const tryOffscreen = typeof canvas.transferControlToOffscreen === "function";
    if (tryOffscreen) {
      try {
        const offscreen = canvas.transferControlToOffscreen();
        const url = ensureWorkerURL();
        const worker = new Worker(url);
        workerRef.current = worker;
        let ready = false;
        const readyTimer = __unframerWindow.setTimeout(() => {
          if (!ready && active) startFallbackNow();
        }, WORKER_TIMEOUT);
        worker.onmessage = (ev) => {
          if (ev.data?.type === "ready") {
            ready = true;
            __unframerWindow.clearTimeout(readyTimer);
            postProps({ fps: 30, paused: false });
          } else if (ev.data?.type === "fatal") {
            __unframerWindow.clearTimeout(readyTimer);
            startFallbackNow();
          }
        };
        worker.onerror = (e) => {
          __unframerWindow.clearTimeout(readyTimer);
          startFallbackNow();
        };
        const dpr = Math.min(__unframerWindow.devicePixelRatio || 1, DPR_CAP);
        const w = Math.max(1, canvas.clientWidth);
        const h = Math.max(1, canvas.clientHeight);
        worker.postMessage({ type: "init", canvas: offscreen, width: w, height: h, dpr, isEditor: false, props: { rotationSpeed: rotRef.current, deformSpeed: speedRef.current, zoom: zoomRef.current, amplitude: ampRef.current, ripK: ripRef.current, textureURL, paused: false, fps: 30 } }, [offscreen]);
        let lastW = 0, lastH = 0, lastDpr = 0;
        let resizeRAF = 0;
        const scheduleResize = () => {
          if (resizeRAF) return;
          resizeRAF = requestAnimationFrame(() => {
            resizeRAF = 0;
            const dprNow = Math.min(__unframerWindow.devicePixelRatio || 1, DPR_CAP);
            const cw = Math.max(1, canvas.clientWidth);
            const ch = Math.max(1, canvas.clientHeight);
            if (cw === lastW && ch === lastH && dprNow === lastDpr) return;
            lastW = cw;
            lastH = ch;
            lastDpr = dprNow;
            workerRef.current?.postMessage({ type: "resize", width: cw, height: ch, dpr: dprNow });
          });
        };
        const ro = new ResizeObserver(scheduleResize);
        ro.observe(canvas);
        scheduleResize();
        roRef.current = ro;
      } catch {
        startFallbackNow();
      }
    } else {
      startFallbackNow();
    }
    return () => {
      if (attemptId !== attemptIdRef.current) return;
      cleanup();
      io.disconnect();
      document.removeEventListener("visibilitychange", onVis);
      if (fallbackRef.current) {
        fallbackRef.current.dispose();
        fallbackRef.current = null;
      }
      if (canvas.parentNode) canvas.parentNode.removeChild(canvas);
    };
  }, [textureURL]);
  React.useEffect(() => {
    postProps({ rotationSpeed });
  }, [rotationSpeed]);
  React.useEffect(() => {
    postProps({ deformSpeed });
  }, [deformSpeed]);
  React.useEffect(() => {
    postProps({ zoom });
  }, [zoom]);
  React.useEffect(() => {
    postProps({ amplitude });
  }, [amplitude]);
  React.useEffect(() => {
    postProps({ ripK });
  }, [ripK]);
  React.useEffect(() => {
    postProps({ textureURL });
  }, [textureURL]);
  const startFallbackMain = (canvas) => {
    if (!isMountedRef.current) return;
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: false, alpha: true, powerPreference: "high-performance" });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.setClearColor(0, 0);
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.set(0, 0, Math.max(0.2, zoomRef.current));
    scene.add(new THREE.HemisphereLight(16777215, 2236979, 1.8));
    const key = new THREE.DirectionalLight(16777215, 2.5);
    key.position.set(2.5, 3, 3.5);
    scene.add(key);
    const geom = new THREE.SphereGeometry(1, SEG_W, SEG_H);
    const uniforms = { uTime: { value: 0 }, uAmp: { value: ampRef.current }, uFreq: { value: FREQ }, uSpeed: { value: speedRef.current }, uRipK: { value: ripRef.current }, uEdgeSoften: { value: EDGE_SOFTEN } };
    const mat = new THREE.MeshStandardMaterial({ color: 16777215, roughness: 0.6, metalness: 0 });
    mat.onBeforeCompile = (shader) => {
      Object.assign(shader.uniforms, uniforms);
      shader.vertexShader = shader.vertexShader.replace("#include <common>", `#include <common>
uniform float uTime,uAmp,uFreq,uSpeed,uRipK,uEdgeSoften;
float hash(vec3 p) {
  p = fract(p * 0.3183099 + .1);
  p *= 10.0;
  return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
}
float noise(vec3 x) {
  vec3 i = floor(x);
  vec3 f = fract(x);
  f = f * f * (3.0 - 2.0 * f);
  return mix(
    mix(mix(hash(i + vec3(0,0,0)), hash(i + vec3(1,0,0)), f.x),
        mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
    mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
        mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y),
    f.z);
}`);
      shader.vertexShader = shader.vertexShader.replace("#include <begin_vertex>", `
vec3 p = position;
vec3 n = normal;
float baseR = length(p);
vec3 dirN = p / baseR;

float edgeMask = 1.0;

float u = 0.5 + 0.5 * atan(dirN.z, dirN.x) / 3.14159265359;
u = u - floor(u);
float v = 0.5 - asin(dirN.y) / 3.14159265359;

float sphericalCoord = u * 6.28318530718 * 0.5 + v * 3.14159265359;

float phaseNoise = 0.08 * noise(dirN * uFreq * 0.8);

float band = sin(uRipK * (sphericalCoord + phaseNoise + uTime * uSpeed));

vec3 transformed = dirN * (baseR * (1.0 + (uAmp * edgeMask) * band));
`);
    };
    mat.needsUpdate = true;
    const mesh = new THREE.Mesh(geom, mat);
    scene.add(mesh);
    let loadId = 0;
    const swapTexture = (url) => {
      if (!url || !isMountedRef.current) return;
      const id = ++loadId;
      new THREE.TextureLoader().load(url, (next) => {
        if (id !== loadId || !isMountedRef.current) {
          next.dispose();
          return;
        }
        next.colorSpace = THREE.SRGBColorSpace;
        next.anisotropy = Math.min(2, renderer.capabilities.getMaxAnisotropy());
        const prev = mat.map;
        mat.map = next;
        next.needsUpdate = true;
        mat.needsUpdate = true;
        if (prev) prev.dispose();
      }, void 0, () => {
      });
    };
    swapTexture(textureURL);
    const resizeState = { w: 0, h: 0, dpr: 0, raf: 0 };
    const scheduleResize = () => {
      if (resizeState.raf) return;
      resizeState.raf = requestAnimationFrame(() => {
        resizeState.raf = 0;
        const dprNow = Math.min(__unframerWindow.devicePixelRatio || 1, DPR_CAP);
        const w = Math.max(1, canvas.clientWidth);
        const h = Math.max(1, canvas.clientHeight);
        if (w === resizeState.w && h === resizeState.h && dprNow === resizeState.dpr) return;
        resizeState.w = w;
        resizeState.h = h;
        resizeState.dpr = dprNow;
        renderer.setPixelRatio(dprNow);
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.render(scene, camera);
      });
    };
    const ro = new ResizeObserver(scheduleResize);
    ro.observe(canvas);
    scheduleResize();
    let targetFps = 30;
    let paused = false;
    let timer = 0;
    const clock = new THREE.Clock();
    function setFps(fps) {
      targetFps = Math.max(8, Math.min(30, Math.floor(fps)));
    }
    function setPaused(v) {
      paused = v;
    }
    const tick = () => {
      if (!isMountedRef.current) return;
      if (paused) {
        timer = __unframerWindow.setTimeout(tick, 250);
        return;
      }
      const dt = Math.min(clock.getDelta(), 0.1);
      camera.position.z = Math.max(0.2, zoomRef.current);
      uniforms.uTime.value += dt;
      if (rotRef.current !== 0) mesh.rotation.y += rotRef.current * dt;
      uniforms.uSpeed.value = speedRef.current;
      uniforms.uAmp.value = ampRef.current;
      uniforms.uRipK.value = ripRef.current;
      renderer.render(scene, camera);
      const delay = Math.floor(1e3 / targetFps);
      timer = __unframerWindow.setTimeout(tick, delay);
    };
    timer = __unframerWindow.setTimeout(tick, 0);
    const onLost = (e) => {
      e.preventDefault();
      try {
        ro.disconnect();
      } catch {
      }
      if (timer) clearTimeout(timer);
      if (mat.map) mat.map.dispose?.();
      geom.dispose();
      mat.dispose();
      renderer.dispose();
      if (isMountedRef.current) setTimeout(() => startFallbackMain(canvas), 100);
    };
    canvas.addEventListener("webglcontextlost", onLost);
    const onVisFallback = () => {
      const hidden = document.hidden;
      setPaused(hidden);
      if (!hidden && !timer) timer = __unframerWindow.setTimeout(tick, 0);
    };
    document.addEventListener("visibilitychange", onVisFallback);
    fallbackRef.current = { setFps, setPaused, swapTexture, dispose: () => {
      document.removeEventListener("visibilitychange", onVisFallback);
      canvas.removeEventListener("webglcontextlost", onLost);
      try {
        ro.disconnect();
      } catch {
      }
      if (timer) clearTimeout(timer);
      if (mat.map) mat.map.dispose?.();
      geom.dispose();
      mat.dispose();
      renderer.dispose();
    } };
  };
  return /* @__PURE__ */ _jsx("div", { ref: hostRef, style: { width: "100%", height: "100%", display: "block", background: "transparent", contentVisibility: "auto", contain: "layout paint size" } });
}
addPropertyControls(RippleSphere, { textureURL: { type: ControlType.Image, title: "Texture", description: "In Editor only the image is shown for performance.", defaultValue: "" }, rotationSpeed: { type: ControlType.Number, title: "Rotate speed", min: -2, max: 2, step: 0.01, defaultValue: -0.6, displayStepper: true }, deformSpeed: { type: ControlType.Number, title: "Deform speed", min: 0, max: 3, step: 0.01, defaultValue: 0.28, displayStepper: true }, amplitude: { type: ControlType.Number, title: "Amplitude", min: 0, max: 1.2, step: 0.01, defaultValue: 0.66, displayStepper: true }, ripK: { type: ControlType.Number, title: "Rip K", min: 1, max: 40, step: 0.1, defaultValue: 8.7, displayStepper: true }, zoom: { type: ControlType.Number, title: "Zoom", min: 1, max: 8, step: 0.01, defaultValue: 3.2, displayStepper: true } });

export {
  RippleSphere
};
