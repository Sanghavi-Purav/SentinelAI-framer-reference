// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 1bd92cedbbf431b3 "Sentinel AI", do not edit manually */
// /:https://framerusercontent.com/modules/fX5JSRKZI4isNfKRernj/c8N9HLRIG24QS8KeF8lF/MorphGPU.js
import { jsx as _jsx } from "react/jsx-runtime";
import { useEffect, useRef, useCallback } from "react";
import { addPropertyControls, ControlType, RenderTarget } from "unframer";
var __unframerWindow = typeof window !== "undefined" ? window : void 0;
var MAX_PIXELS = 5e5;
var MOBILE_MAX = 809;
var IO_THRESHOLD = 0.15;
var imageCache = /* @__PURE__ */ new Map();
var STATIC_WORKER_URL = null;
function rafThrottle(fn) {
  let pending = false;
  let lastArgs = null;
  return (...args) => {
    lastArgs = args;
    if (pending) return;
    pending = true;
    requestAnimationFrame(() => {
      pending = false;
      fn(...lastArgs);
    });
  };
}
function getCachedImage(src) {
  if (!src) return null;
  if (imageCache.has(src)) return imageCache.get(src);
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.referrerPolicy = "no-referrer";
  imageCache.set(src, img);
  return img;
}
function intersectionRatio(el) {
  const r = el.getBoundingClientRect();
  const vw = __unframerWindow.innerWidth || 0;
  const vh = __unframerWindow.innerHeight || 0;
  if (r.width <= 0 || r.height <= 0 || vw <= 0 || vh <= 0) return 0;
  const ix = Math.max(0, Math.min(r.right, vw) - Math.max(r.left, 0));
  const iy = Math.max(0, Math.min(r.bottom, vh) - Math.max(r.top, 0));
  const inter = ix * iy;
  return inter > 0 ? inter / (r.width * r.height) : 0;
}
function MorphGPU(props) {
  const { imgA = "", imgB = "", morphMs = 5e3, pauseMs = 1e3, underlayStart = 0.2, stopMotionInEditor = true, width = 600, height = 400 } = props;
  const rootRef = useRef(null);
  const canvasRef = useRef(null);
  const workerRef = useRef(null);
  const resizeObsRef = useRef(null);
  const ioRef = useRef(null);
  const prevPropsRef = useRef({ morphMs, pauseMs, underlayStart });
  const prevPathsRef = useRef({ imgA, imgB });
  const activeStateRef = useRef({ inView: true, visible: typeof document !== "undefined" ? document.visibilityState === "visible" : true, active: false });
  const updateActive = useCallback(() => {
    const next = activeStateRef.current.inView && activeStateRef.current.visible;
    if (next !== activeStateRef.current.active) {
      activeStateRef.current.active = next;
      workerRef.current?.postMessage({ type: "setActive", active: next });
    }
  }, []);
  const drawStaticFirst = useCallback(() => {
    const root = rootRef.current;
    const cvs = canvasRef.current;
    if (!root || !cvs) return;
    const c2d = cvs.getContext("2d");
    if (!c2d) return;
    const dpr = Math.min(__unframerWindow.devicePixelRatio || 1, 2);
    const elW = Math.max(1, root.clientWidth);
    const elH = Math.max(1, root.clientHeight);
    const pixelRatio = Math.min(1, Math.sqrt(MAX_PIXELS / (elW * elH * dpr * dpr)));
    const finalDpr = dpr * pixelRatio;
    cvs.width = Math.floor(elW * finalDpr);
    cvs.height = Math.floor(elH * finalDpr);
    c2d.resetTransform?.();
    c2d.setTransform(finalDpr, 0, 0, finalDpr, 0, 0);
    c2d.clearRect(0, 0, elW, elH);
    const img = getCachedImage(imgA);
    if (!img) return;
    const drawImage = () => {
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;
      if (!iw || !ih) return;
      const rI = iw / ih;
      const rV = elW / elH;
      const dw = rI > rV ? elH * rI : elW;
      const dh = rI > rV ? elH : elW / rI;
      c2d.save();
      c2d.translate(elW / 2, elH / 2);
      c2d.rotate(Math.PI);
      c2d.scale(-1, 1);
      c2d.imageSmoothingEnabled = true;
      c2d.drawImage(img, -dw / 2, -dh / 2, dw, dh);
      c2d.restore();
    };
    if ("decode" in img && typeof img.decode === "function") {
      img.src = imgA || "";
      img.decode().then(drawImage).catch(() => {
        img.onload = drawImage;
      });
    } else {
      img.onload = drawImage;
      img.src = imgA || "";
    }
  }, [imgA]);
  const throttledDrawStatic = useRef(rafThrottle(() => drawStaticFirst())).current;
  useEffect(() => {
    const root = rootRef.current;
    const cvs = canvasRef.current;
    if (!root || !cvs) return;
    const applyElementSize = () => {
      const elW2 = Math.max(1, root.clientWidth);
      const elH2 = Math.max(1, root.clientHeight);
      cvs.style.width = elW2 + "px";
      cvs.style.height = elH2 + "px";
    };
    applyElementSize();
    const isEditorCanvas = RenderTarget.current() === RenderTarget.canvas;
    const SHOULD_STOP = stopMotionInEditor && isEditorCanvas;
    const IS_MOBILE = typeof __unframerWindow !== "undefined" && __unframerWindow.matchMedia?.(`(max-width: ${MOBILE_MAX}px)`)?.matches === true;
    const supportsOffscreen = typeof HTMLCanvasElement.prototype.transferControlToOffscreen === "function" && typeof Worker !== "undefined";
    if (SHOULD_STOP || IS_MOBILE || !supportsOffscreen || !imgA || !imgB) {
      drawStaticFirst();
      const ro2 = new ResizeObserver(() => throttledDrawStatic());
      ro2.observe(root);
      resizeObsRef.current = ro2;
      return () => {
        try {
          ro2.disconnect();
        } catch {
        }
        resizeObsRef.current = null;
      };
    }
    if (workerRef.current) {
      try {
        workerRef.current.postMessage({ type: "dispose" });
        workerRef.current.terminate();
      } catch {
      }
      workerRef.current = null;
    }
    if (!STATIC_WORKER_URL) {
      const blob = new Blob([WORKER_SOURCE], { type: "application/javascript" });
      STATIC_WORKER_URL = URL.createObjectURL(blob);
    }
    const worker = new Worker(STATIC_WORKER_URL, { name: "MorphGPUWorker" });
    workerRef.current = worker;
    const dpr = Math.min(__unframerWindow.devicePixelRatio || 1, 2);
    const elW = Math.max(1, root.clientWidth);
    const elH = Math.max(1, root.clientHeight);
    const pixelRatio = Math.min(1, Math.sqrt(MAX_PIXELS / (elW * elH * dpr * dpr)));
    const finalDpr = dpr * pixelRatio;
    const ratioNow = intersectionRatio(root);
    const initialActive = ratioNow > IO_THRESHOLD && (typeof document === "undefined" || document.visibilityState === "visible");
    const offscreen = cvs.transferControlToOffscreen();
    worker.postMessage({ type: "init", canvas: offscreen, size: { w: elW, h: elH }, dpr: finalDpr, initialActive, props: { imgA, imgB, morphMs, pauseMs, underlayStart } }, [offscreen]);
    activeStateRef.current.inView = ratioNow > IO_THRESHOLD;
    activeStateRef.current.visible = typeof document === "undefined" ? true : document.visibilityState === "visible";
    activeStateRef.current.active = initialActive;
    let lastW = elW;
    let lastH = elH;
    const handleResize = rafThrottle((entries) => {
      const cr = entries[0].contentRect;
      const newW = Math.max(1, Math.floor(cr.width));
      const newH = Math.max(1, Math.floor(cr.height));
      if (newW === lastW && newH === lastH) return;
      lastW = newW;
      lastH = newH;
      applyElementSize();
      const _dpr = Math.min(__unframerWindow.devicePixelRatio || 1, 2);
      const pr = Math.min(1, Math.sqrt(MAX_PIXELS / (newW * newH * _dpr * _dpr)));
      worker.postMessage({ type: "resize", size: { w: newW, h: newH }, dpr: _dpr * pr });
      activeStateRef.current.inView = intersectionRatio(root) > IO_THRESHOLD;
      updateActive();
    });
    const ro = new ResizeObserver(handleResize);
    ro.observe(root);
    resizeObsRef.current = ro;
    const io = new IntersectionObserver(([e]) => {
      activeStateRef.current.inView = e.isIntersecting && e.intersectionRatio > IO_THRESHOLD;
      updateActive();
    }, { threshold: IO_THRESHOLD });
    io.observe(root);
    ioRef.current = io;
    const visHandler = () => {
      activeStateRef.current.visible = document.visibilityState === "visible";
      updateActive();
    };
    document.addEventListener("visibilitychange", visHandler);
    return () => {
      try {
        ro.disconnect();
      } catch {
      }
      resizeObsRef.current = null;
      try {
        io.disconnect();
      } catch {
      }
      ioRef.current = null;
      document.removeEventListener("visibilitychange", visHandler);
      if (workerRef.current) {
        try {
          workerRef.current.postMessage({ type: "dispose" });
          workerRef.current.terminate();
        } catch {
        }
        workerRef.current = null;
      }
    };
  }, [drawStaticFirst, throttledDrawStatic, updateActive, imgA, imgB, morphMs, pauseMs, underlayStart, stopMotionInEditor]);
  useEffect(() => {
    const prev = prevPropsRef.current;
    if (prev.morphMs !== morphMs || prev.pauseMs !== pauseMs || prev.underlayStart !== underlayStart) {
      workerRef.current?.postMessage({ type: "updateProps", props: { morphMs, pauseMs, underlayStart } });
      prevPropsRef.current = { morphMs, pauseMs, underlayStart };
    }
  }, [morphMs, pauseMs, underlayStart]);
  useEffect(() => {
    const root = rootRef.current;
    const cvs = canvasRef.current;
    if (!root || !cvs) return;
    const isEditorCanvas = RenderTarget.current() === RenderTarget.canvas;
    const SHOULD_STOP = stopMotionInEditor && isEditorCanvas;
    const IS_MOBILE = typeof __unframerWindow !== "undefined" && __unframerWindow.matchMedia?.(`(max-width: ${MOBILE_MAX}px)`)?.matches === true;
    if (SHOULD_STOP || IS_MOBILE || !imgA || !imgB) {
      throttledDrawStatic();
    }
    const prev = prevPathsRef.current;
    if (prev.imgA !== imgA || prev.imgB !== imgB) {
      prevPathsRef.current = { imgA, imgB };
      if (workerRef.current && !SHOULD_STOP && !IS_MOBILE) {
        workerRef.current.postMessage({ type: "reloadImages", props: { imgA, imgB } });
      }
    }
  }, [imgA, imgB, stopMotionInEditor, throttledDrawStatic]);
  return /* @__PURE__ */ _jsx("div", { ref: rootRef, style: { width: "100%", height: "100%", position: "relative", background: "transparent", overflow: "hidden", contain: "layout style paint size", contentVisibility: "auto" }, children: /* @__PURE__ */ _jsx("canvas", { ref: canvasRef, style: { display: "block", background: "transparent" }, width, height }) });
}
addPropertyControls(MorphGPU, { imgA: { type: ControlType.Image, title: "Image A" }, imgB: { type: ControlType.Image, title: "Image B" }, morphMs: { type: ControlType.Number, title: "Morph ms", min: 0, max: 2e4, step: 50, displayStepper: true, defaultValue: 5e3 }, pauseMs: { type: ControlType.Number, title: "Pause ms", min: 0, max: 1e4, step: 50, displayStepper: true, defaultValue: 1e3 }, underlayStart: { type: ControlType.Number, title: "Underlay Start", min: 0, max: 0.95, step: 0.01, defaultValue: 0.2 } });
var WORKER_SOURCE = `

let gl = null
let canvas = null
let size = { w: 1, h: 1 }
let dpr = 1

let gen = 0

let morphMs = 5000
let pauseMs = 1000
let underlayStart = 0.2

const MAX_PIXELS = 500000
const BINS = 512
const TAIL_GAMMA = 1.9
const KERNEL_GAMMA = 1.6
const LAND_L0 = 0.86
const LAND_L1 = 1.0
const RESOLVE_FADE_L0 = 0.9
const RESOLVE_FADE_L1 = 1.0

const TEXU_TEXA = 0, TEXU_TEXB = 1, TEXU_MAP = 2, TEXU_ACC = 3

let texA = null, texB = null
let texAW = 0, texAH = 0, texBW = 0, texBH = 0
let map01Tex = null, map10Tex = null
let accum = null

let bmpA = null, bmpB = null

let curr = 0
let killed = false
let isRunning = false
let active = true
let raf = null
let startT = 0

let progAccum = null, progResolve = null, progBlit = null
let u_acc_uTMotion = null, u_acc_uWH = null, u_acc_uT = null, u_acc_uKernel = null
let u_res_uAccum = null, u_res_uAlpha = null
let u_blit_uTex = null, u_blit_uAlpha = null

const hasRAF = typeof self.requestAnimationFrame === 'function'
function nextFrame(cb){ return hasRAF ? self.requestAnimationFrame(cb) : setTimeout(()=>cb(performance.now()),16) }
function cancelFrame(h){ if(hasRAF) self.cancelAnimationFrame(h); else clearTimeout(h) }

async function loadBitmap(url){
  if(!url) throw new Error('Empty URL')
  const res = await fetch(url, { mode:'cors', credentials:'omit', cache:'force-cache' })
  if(!res.ok) throw new Error('fetch failed: '+res.status)
  const blob = await res.blob()
  const bmp = await createImageBitmap(blob, { colorSpaceConversion: "none", premultiplyAlpha: "none" })
  return bmp
}

function coverSize(iw, ih, vw, vh){
  const rI = iw/ih, rV = vw/vh
  return rI > rV ? [vh*rI, vh] : [vw, vw/rI]
}

function drawCoverToImageData(bmp, W, H){
  const off = new OffscreenCanvas(W, H)
  const ctx = off.getContext('2d', { willReadFrequently: true })
  const iw = bmp.width, ih = bmp.height
  const [dw, dh] = coverSize(iw, ih, W, H)
  const dx = (W - dw)*0.5, dy = (H - dh)*0.5
  ctx.clearRect(0,0,W,H)
  ctx.imageSmoothingEnabled = true
  ctx.drawImage(bmp, dx, dy, dw, dh)
  return ctx.getImageData(0,0,W,H)
}

function lumaLin(r,g,b){ 
  function to(c){c/=255;return c<=0.04045?c/12.92:Math.pow((c+0.055)/1.055,2.4)}; 
  return 0.2126*to(r)+0.7152*to(g)+0.0722*to(b) 
}

function computeLuma(imgData){
  const data = imgData.data, N = data.length>>2
  const L = new Float32Array(N)
  for(let i=0,k=0;i<data.length;i+=4,k++) L[k]=lumaLin(data[i],data[i+1],data[i+2])
  return L
}

function smootherstep01(x){ const t=Math.min(1,Math.max(0,x)); return t*t*t*(t*(6*t-15)+10) }
function smoothstep(a,b,x){ const t=Math.min(1,Math.max(0,(x-a)/Math.max(b-a,1e-6))); return t*t*(3-2*t) }
function tailEase(t,k){ return 1.0 - Math.pow(1.0 - t, k) }
function part1by1(n){ n&=0xffff; n=(n|(n<<8))&0x00ff00ff; n=(n|(n<<4))&0x0f0f0f0f; n=(n|(n<<2))&0x33333333; n=(n|(n<<1))&0x55555555; return n }
function morton(x,y){ return (part1by1(y)<<1)|part1by1(x) }

function createProgram(vsSrc,fsSrc){
  const vs=gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs,vsSrc); gl.compileShader(vs)
  if(!gl.getShaderParameter(vs,gl.COMPILE_STATUS)) throw new Error('VS: '+gl.getShaderInfoLog(vs))
  const fs=gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs,fsSrc); gl.compileShader(fs)
  if(!gl.getShaderParameter(fs,gl.COMPILE_STATUS)) throw new Error('FS: '+gl.getShaderInfoLog(fs))
  const p=gl.createProgram(); gl.attachShader(p,vs); gl.attachShader(p,fs); gl.linkProgram(p)
  if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error('LINK: '+gl.getProgramInfoLog(p))
  gl.deleteShader(vs); gl.deleteShader(fs); return p
}

function makeTextureFromImageData(imgData, filter){
  const t=gl.createTexture()
  gl.bindTexture(gl.TEXTURE_2D,t)
  gl.pixelStorei(gl.UNPACK_ALIGNMENT,1)
  gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE)
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,filter)
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,filter)
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE)
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE)
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,imgData.width,imgData.height,0,gl.RGBA,gl.UNSIGNED_BYTE,imgData.data)
  return t
}

function updateTextureSub(existing, imgData){
  gl.bindTexture(gl.TEXTURE_2D, existing)
  gl.pixelStorei(gl.UNPACK_ALIGNMENT,1)
  gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE)
  gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,imgData.width,imgData.height,gl.RGBA,gl.UNSIGNED_BYTE,imgData.data)
}

function makeRG32FTexTopUV(W,H,data){
  const t=gl.createTexture()
  gl.bindTexture(gl.TEXTURE_2D,t)
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE)
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE)
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RG32F,W,H,0,gl.RG,gl.FLOAT,data)
  return t
}

function makeAccumTarget(W,H){
  const tex=gl.createTexture()
  gl.bindTexture(gl.TEXTURE_2D,tex)
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE)
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE)
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA16F,W,H,0,gl.RGBA,gl.HALF_FLOAT,null)
  const fbo=gl.createFramebuffer()
  gl.bindFramebuffer(gl.FRAMEBUFFER,fbo)
  gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,tex,0)
  if(gl.checkFramebufferStatus(gl.FRAMEBUFFER)!==gl.FRAMEBUFFER_COMPLETE) throw new Error('FBO incomplete')
  gl.bindFramebuffer(gl.FRAMEBUFFER,null)
  return { fbo, tex }
}

function resizeTo(elW, elH){
  let W=Math.max(1,Math.floor(elW*dpr)), H=Math.max(1,Math.floor(elH*dpr))
  const px=W*H
  if(px>MAX_PIXELS){ const s=Math.sqrt(MAX_PIXELS/px); W=Math.max(1,Math.floor(W*s)); H=Math.max(1,Math.floor(H*s)) }
  if (canvas.width === W && canvas.height === H) return { W: canvas.width, H: canvas.height }
  canvas.width=W; canvas.height=H
  gl.viewport(0,0,W,H)
  return { W, H }
}
let dims={ W:1, H:1 }

function buildMapping(W,H,L0,L1){
  const N=W*H, B0=Array.from({length:BINS},()=>[]), B1=Array.from({length:BINS},()=>[])
  for(let k=0;k<N;k++){ 
    const b0=Math.min(BINS-1,Math.max(0,(L0[k]*BINS)|0)); 
    const b1=Math.min(BINS-1,Math.max(0,(L1[k]*BINS)|0)); 
    B0[b0].push(k); B1[b1].push(k) 
  }
  const sortMorton=arr=>arr.sort((a,b)=>{ 
    const ax=a%W, ay=(a/W)|0, bx=b%W, by=(b/W)|0; 
    return morton(ax,ay)-morton(bx,by) 
  })
  for(let b=0;b<BINS;b++){ if(B0[b].length) sortMorton(B0[b]); if(B1[b].length) sortMorton(B1[b]) }
  const mapAB=new Uint32Array(N), mapBA=new Uint32Array(N); 
  let spillA=[], spillB=[]
  for(let b=0;b<BINS;b++){
    const A=B0[b], B=B1[b], m=Math.min(A.length,B.length)
    for(let i=0;i<m;i++){ const a=A[i], t=B[i]; mapAB[a]=t; mapBA[t]=a }
    if(A.length>m) spillA.push(...A.slice(m)); if(B.length>m) spillB.push(...B.slice(m))
    const r=Math.min(spillA.length,spillB.length)
    for(let i=0;i<r;i++){ const a=spillA[i], t=spillB[i]; mapAB[a]=t; mapBA[t]=a }
    if(r){ spillA=spillA.slice(r); spillB=spillB.slice(r) }
  }
  for(let i=0;i<spillA.length;i++) mapAB[spillA[i]]=spillA[i]
  for(let i=0;i<spillB.length;i++) mapBA[spillB[i]]=spillB[i]
  return { map01: mapAB, map10: mapBA }
}

function mapIndicesToUVTop(mapIdx,W,H){
  const N=W*H, out=new Float32Array(N*2)
  for(let k=0;k<N;k++){ const j=mapIdx[k], tx=j%W, ty=(j/W)|0; out[k*2]=(tx+0.5)/W; out[k*2+1]=(ty+0.5)/H }
  return out
}

// ---------- shaders ----------
const FULL_VS = \`#version 300 es
precision highp float;
out vec2 vUVTop;
void main(){
  vec2 pos = vec2( (gl_VertexID==0)?-1.0: (gl_VertexID==1)? 3.0: -1.0,
                   (gl_VertexID==0)?-1.0: (gl_VertexID==1)?-1.0:  3.0 );
  gl_Position = vec4(pos, 0.0, 1.0);
  vUVTop = 0.5*(pos+1.0);
  vUVTop.y = 1.0 - vUVTop.y;
}\`
const ACCUM_VS = \`#version 300 es
precision highp float;
uniform vec2  uWH;
uniform float uTMotion;
uniform float uKernel;
uniform sampler2D uMap;
out vec2 vSrcUVTop;
out vec2 vDstUVTop;
void main(){
  int W = int(uWH.x);
  int id = gl_VertexID;
  int x = id % W;
  int y = id / W;

  vec2 srcUVTop = (vec2(float(x)+0.5, float(y)+0.5)) / uWH;
  vec2 dstUVTop = texture(uMap, srcUVTop).rg;

  vec2 srcPx = srcUVTop * uWH;
  vec2 dstPx = dstUVTop * uWH;
  vec2 posPx = mix(srcPx, dstPx, uTMotion);
  vec2 posUVTop = posPx / uWH;

  vec2 ndc = vec2(2.0*posUVTop.x - 1.0, 1.0 - 2.0*posUVTop.y);
  gl_Position = vec4(ndc, 0.0, 1.0);

  gl_PointSize = max(1.8, 2.2 * uKernel);

  vSrcUVTop = srcUVTop;
  vDstUVTop = dstUVTop;
}\`
const ACCUM_FS = \`#version 300 es
precision highp float;
uniform sampler2D uTexA;
uniform sampler2D uTexB;
uniform float uT;
in vec2 vSrcUVTop;
in vec2 vDstUVTop;
out vec4 fragColor;
void main(){
  float r = length(gl_PointCoord - vec2(0.5)) * 2.0;
  float w = pow(max(1.0 - r, 0.0), 2.5);

  vec2 uvA = vec2(vSrcUVTop.x, 1.0 - vSrcUVTop.y);
  vec2 uvB = vec2(vDstUVTop.x, 1.0 - vDstUVTop.y);

  vec3 a = texture(uTexA, uvA).rgb;
  vec3 b = texture(uTexB, uvB).rgb;

  float mixB = smoothstep(0.5, 1.0, uT);
  vec3 c = mix(a, b, mixB);

  fragColor = vec4(c * w, w);
}\`
const RESOLVE_VS = FULL_VS
const RESOLVE_FS = \`#version 300 es
precision highp float;
uniform sampler2D uAccum;
uniform float uResolveAlpha;
in vec2 vUVTop;
out vec4 fragColor;
void main(){
  vec2 uv = vec2(vUVTop.x, 1.0 - vUVTop.y);
  vec4 s = texture(uAccum, uv);
  float w = s.a;
  if(w <= 1e-6) fragColor = vec4(0.0,0.0,0.0,0.0);
  else          fragColor = vec4(s.rgb / w, clamp(w, 0.0, 1.0) * uResolveAlpha);
}\`
const BLIT_VS = FULL_VS
const BLIT_FS = \`#version 300 es
precision highp float;
uniform sampler2D uTex;
uniform float uAlpha;
in vec2 vUVTop;
out vec4 fragColor;
void main(){
  vec2 uv = vec2(vUVTop.x, 1.0 - vUVTop.y);
  vec3 c = texture(uTex, uv).rgb;
  fragColor = vec4(c, uAlpha);
}\`

function drawUnderlay(tMotion01, dir01){
  const s=Math.min(0.99,Math.max(0.0,underlayStart))
  const tau=Math.min(1,Math.max(0,(tMotion01-s)/Math.max(1.0-s,1e-4)))
  const overAlpha=tau*tau*(3.0-2.0*tau)
  const baseTex=dir01?texA:texB, overTex=dir01?texB:texA

  gl.bindFramebuffer(gl.FRAMEBUFFER,null)
  gl.viewport(0,0,dims.W,dims.H)
  gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT)

  gl.disable(gl.BLEND)
  gl.useProgram(progBlit)
  gl.activeTexture(gl.TEXTURE0+TEXU_TEXA)
  gl.bindTexture(gl.TEXTURE_2D, baseTex)
  gl.uniform1i(u_blit_uTex, TEXU_TEXA)
  gl.uniform1f(u_blit_uAlpha, 1.0)
  gl.drawArrays(gl.TRIANGLES,0,3)

  gl.enable(gl.BLEND)
  gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA)
  gl.useProgram(progBlit)
  gl.activeTexture(gl.TEXTURE0+TEXU_TEXA)
  gl.bindTexture(gl.TEXTURE_2D, overTex)
  gl.uniform1i(u_blit_uTex, TEXU_TEXA)
  gl.uniform1f(u_blit_uAlpha, overAlpha)
  gl.drawArrays(gl.TRIANGLES,0,3)
}

function renderMorphFrame(t01, dir01){
  const tSm=smootherstep01(t01)
  const tMotion=tailEase(tSm, TAIL_GAMMA)
  const land=Math.min(1,Math.max(0,(tMotion-LAND_L0)/(LAND_L1-LAND_L0)))
  const landS=land*land*(3.0-2.0*land)
  const kernelScale=Math.pow(Math.max(0.0,1.0-landS), KERNEL_GAMMA)

  drawUnderlay(tMotion, dir01)

  gl.bindFramebuffer(gl.FRAMEBUFFER,accum.fbo)
  gl.disable(gl.DEPTH_TEST); gl.disable(gl.CULL_FACE); gl.disable(gl.DITHER)
  gl.enable(gl.BLEND); gl.blendFunc(gl.ONE,gl.ONE)
  gl.viewport(0,0,dims.W,dims.H)
  gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT)

  gl.useProgram(progAccum)
  gl.uniform2f(u_acc_uWH,dims.W,dims.H)
  gl.uniform1f(u_acc_uT,tMotion)
  gl.uniform1f(u_acc_uTMotion,tMotion)
  gl.uniform1f(u_acc_uKernel,kernelScale)

  gl.activeTexture(gl.TEXTURE0+TEXU_TEXA)
  gl.bindTexture(gl.TEXTURE_2D, dir01?texA:texB)
  gl.uniform1i(gl.getUniformLocation(progAccum,"uTexA"),TEXU_TEXA)

  gl.activeTexture(gl.TEXTURE0+TEXU_TEXB)
  gl.bindTexture(gl.TEXTURE_2D, dir01?texB:texA)
  gl.uniform1i(gl.getUniformLocation(progAccum,"uTexB"),TEXU_TEXB)

  gl.activeTexture(gl.TEXTURE0+TEXU_MAP)
  gl.bindTexture(gl.TEXTURE_2D, dir01?map01Tex:map10Tex)
  gl.uniform1i(gl.getUniformLocation(progAccum,"uMap"),TEXU_MAP)

  gl.drawArrays(gl.POINTS,0,dims.W*dims.H)

  gl.bindFramebuffer(gl.FRAMEBUFFER,null)
  gl.viewport(0,0,dims.W,dims.H)
  gl.enable(gl.BLEND)
  gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA)
  gl.useProgram(progResolve)
  gl.activeTexture(gl.TEXTURE0+TEXU_ACC)
  gl.bindTexture(gl.TEXTURE_2D,accum.tex)
  gl.uniform1i(u_res_uAccum,TEXU_ACC)
  const resolveAlpha=1.0 - smoothstep(RESOLVE_FADE_L0,RESOLVE_FADE_L1,tMotion)
  gl.uniform1f(u_res_uAlpha,resolveAlpha)
  gl.drawArrays(gl.TRIANGLES,0,3)
  gl.disable(gl.BLEND)
}

function drawExact(){
  gl.bindFramebuffer(gl.FRAMEBUFFER,null)
  gl.viewport(0,0,dims.W,dims.H)
  gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT)
  gl.useProgram(progBlit)
  const tex = curr===0 ? texA : texB
  gl.disable(gl.BLEND)
  gl.activeTexture(gl.TEXTURE0+TEXU_TEXA)
  gl.bindTexture(gl.TEXTURE_2D, tex)
  gl.uniform1i(u_blit_uTex, TEXU_TEXA)
  gl.uniform1f(u_blit_uAlpha, 1.0)
  gl.drawArrays(gl.TRIANGLES,0,3)
}

function morph(dir01,onDone){
  if(killed || !active) return
  const myGen = gen
  startT=performance.now()
  if(raf) cancelFrame(raf)
  const tick=(now)=>{
    if(killed || !active || myGen !== gen) return
    const u=Math.min(1,Math.max(0,(now-startT)/morphMs))
    if(u<1){ 
      renderMorphFrame(u,dir01); 
      raf=nextFrame(tick) 
    } else { 
      renderMorphFrame(1,dir01); 
      curr=dir01?1:0; 
      onDone&&onDone() 
    }
  }
  raf=nextFrame(tick)
}
const hold=(ms)=>new Promise(r=>setTimeout(r,ms))

async function runCycle(){ 
  if(isRunning || killed || !active) return
  const myGen = gen
  isRunning = true
  try {
    drawExact()
    while(!killed && active && myGen === gen){ 
      await hold(pauseMs)
      if(killed || !active || myGen !== gen) break
      await new Promise(res=>morph(curr===0,res))
      if(killed || !active || myGen !== gen) break
    }
  } finally {
    isRunning = false
  }
}

function rebuildForSize(recreateTextures){
  if(!bmpA || !bmpB || !gl) return
  const W = dims.W, H = dims.H
  const img0Data = drawCoverToImageData(bmpA,W,H)
  const img1Data = drawCoverToImageData(bmpB,W,H)

  if (!texA || recreateTextures || texAW !== W || texAH !== H) {
    if (texA) gl.deleteTexture(texA)
    texA = makeTextureFromImageData(img0Data, gl.LINEAR)
    texAW = W; texAH = H
  } else {
    updateTextureSub(texA, img0Data)
  }

  if (!texB || recreateTextures || texBW !== W || texBH !== H) {
    if (texB) gl.deleteTexture(texB)
    texB = makeTextureFromImageData(img1Data, gl.LINEAR)
    texBW = W; texBH = H
  } else {
    updateTextureSub(texB, img1Data)
  }

  const L0 = computeLuma(img0Data), L1 = computeLuma(img1Data)
  const maps = buildMapping(W,H,L0,L1)
  const map01UVTop=mapIndicesToUVTop(maps.map01,W,H)
  const map10UVTop=mapIndicesToUVTop(maps.map10,W,H)
  if(map01Tex) gl.deleteTexture(map01Tex)
  if(map10Tex) gl.deleteTexture(map10Tex)
  map01Tex=makeRG32FTexTopUV(W,H,map01UVTop)
  map10Tex=makeRG32FTexTopUV(W,H,map10UVTop)

  if(accum){ gl.deleteTexture(accum.tex); gl.deleteFramebuffer(accum.fbo) }
  accum=makeAccumTarget(W,H)
}

async function init(msg){
  canvas=msg.canvas; size=msg.size; dpr=Math.min(msg.dpr||1,2)
  morphMs=msg.props.morphMs; pauseMs=msg.props.pauseMs; underlayStart=msg.props.underlayStart

  gl=canvas.getContext('webgl2',{
    alpha:false, antialias:false, premultipliedAlpha:false,
    preserveDrawingBuffer:false, desynchronized:true,
    powerPreference:'high-performance'
  })
  if(!gl) { console.error('WebGL2 not supported'); return }
  if(!gl.getExtension('EXT_color_buffer_float')) { console.error('EXT_color_buffer_float not supported'); return }

  try {
    gl.bindVertexArray(gl.createVertexArray())
    progAccum=createProgram(ACCUM_VS,ACCUM_FS)
    progResolve=createProgram(RESOLVE_VS,RESOLVE_FS)
    progBlit=createProgram(BLIT_VS,BLIT_FS)
    u_acc_uTMotion=gl.getUniformLocation(progAccum,'uTMotion')
    u_acc_uWH=gl.getUniformLocation(progAccum,'uWH')
    u_acc_uT=gl.getUniformLocation(progAccum,'uT')
    u_acc_uKernel=gl.getUniformLocation(progAccum,'uKernel')
    u_res_uAccum=gl.getUniformLocation(progResolve,'uAccum')
    u_res_uAlpha=gl.getUniformLocation(progResolve,'uResolveAlpha')
    u_blit_uTex=gl.getUniformLocation(progBlit,'uTex')
    u_blit_uAlpha=gl.getUniformLocation(progBlit,'uAlpha')

    const [bA,bB]=await Promise.all([loadBitmap(msg.props.imgA),loadBitmap(msg.props.imgB)])
    bmpA=bA; bmpB=bB
    dims=resizeTo(size.w,size.h)

    rebuildForSize(true)
    // Start based on initialActive
    curr = 0
    drawExact()
    killed=false
    active = !!msg.initialActive
    if (active) runCycle()
  } catch (e) {
    console.error('Worker init failed:', e)
    killed = true
    isRunning = false
  }
}

self.onmessage = (e)=>{
  const m=e.data
  if(m.type==='init') {
    init(m).catch(err => console.error('Init error:', err))
  } else if(m.type==='resize'){
    size=m.size; dpr=Math.min(m.dpr||1,2)
    if(!gl||!canvas) return
    const oldW = canvas.width, oldH = canvas.height
    dims=resizeTo(size.w,size.h)
    const changed = (oldW !== dims.W || oldH !== dims.H)
    if(bmpA&&bmpB){ rebuildForSize(changed); drawExact() }
  } else if(m.type==='updateProps'){
    if(typeof m.props.morphMs==='number') morphMs=m.props.morphMs
    if(typeof m.props.pauseMs==='number') pauseMs=m.props.pauseMs
    if(typeof m.props.underlayStart==='number') underlayStart=m.props.underlayStart
  } else if(m.type==='reloadImages'){
    (async () => {
      try {
        const [bA, bB] = await Promise.all([loadBitmap(m.props.imgA), loadBitmap(m.props.imgB)])
        if (bmpA && 'close' in bmpA) try{ bmpA.close() }catch(_){}
        if (bmpB && 'close' in bmpB) try{ bmpB.close() }catch(_){}
        bmpA = bA; bmpB = bB
        rebuildForSize(false)
        curr = 0
        drawExact()
      } catch(err) {
        console.error('reloadImages failed', err)
      }
    })()
} else if(m.type==='setActive'){
  const becomingActive = !!m.active
  if (!becomingActive){
    active = false
    gen++
    if(raf){ cancelFrame(raf); raf=null }
    isRunning = false                // <\u2014 \u0447\u0442\u043E\u0431\u044B \xAB\u0437\u0430\u043C\u043E\u0440\u043E\u0436\u0435\u043D\u043D\u044B\u0439\xBB \u0446\u0438\u043A\u043B \u043D\u0435 \u043C\u0435\u0448\u0430\u043B \u043F\u0435\u0440\u0435\u0437\u0430\u043F\u0443\u0441\u043A\u0443
    return
  }

  // \u0412\u043E\u0437\u0432\u0440\u0430\u0442 \u0432 viewport: \u0441\u0440\u0430\u0437\u0443 \u0442\u0440\u0438\u0433\u0433\u0435\u0440\u0438\u043C \u044D\u0444\u0444\u0435\u043A\u0442
  active = true
  gen++
  curr = 0                           // \u0432\u0441\u0435\u0433\u0434\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0435\u043C \u0441 Image A
  drawExact()
  if(raf){ cancelFrame(raf); raf=null }

  const myGen = gen
  isRunning = true
  morph(curr === 0, () => {          // \u043C\u0433\u043D\u043E\u0432\u0435\u043D\u043D\u043E \u0432\u044B\u043F\u043E\u043B\u043D\u044F\u0435\u043C \u043F\u0435\u0440\u0432\u044B\u0439 morph A->B
    if (killed || !active || myGen !== gen){ 
      isRunning = false
      return
    }
    isRunning = false
    runCycle()                       // \u0434\u0430\u043B\u044C\u0448\u0435 \u2014 \u043E\u0431\u044B\u0447\u043D\u044B\u0439 \u0446\u0438\u043A\u043B \u0441 \u043F\u0430\u0443\u0437\u0430\u043C\u0438
  })
}
 else if(m.type==='dispose'){
    killed=true; 
    active=false
    isRunning = false
    if(raf) cancelFrame(raf)
    try{
      if(texA) gl.deleteTexture(texA)
      if(texB) gl.deleteTexture(texB)
      if(map01Tex) gl.deleteTexture(map01Tex)
      if(map10Tex) gl.deleteTexture(map10Tex)
      if(accum){ gl.deleteTexture(accum.tex); gl.deleteFramebuffer(accum.fbo) }
      if(gl) {
        const programs = [progAccum, progResolve, progBlit].filter(Boolean)
        programs.forEach(p => gl.deleteProgram(p))
      }
      if (bmpA && 'close' in bmpA) bmpA.close()
      if (bmpB && 'close' in bmpB) bmpB.close()
    }catch(_){}
  }
}
`;

export {
  MorphGPU
};
