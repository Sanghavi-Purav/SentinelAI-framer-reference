// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 1bd92cedbbf431b3 "Sentinel AI", do not edit manually */
// /:https://framerusercontent.com/modules/edEWFbYVOQOX7K3bHFFg/adW3k4uHhGpssHicZZJQ/ZipText.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import * as React from "react";
import { addPropertyControls, ControlType, RenderTarget } from "unframer";
var __unframerWindow = typeof window !== "undefined" ? window : void 0;
var CHAR_KF = "aco_char_in_smooth";
var LINE_KF = "aco_line_slide_exact";
var REF_FONTSIZE = 100;
function fontCSS(font) {
  if (!font || typeof font === "string") {
    return { fontFamily: typeof font === "string" ? font : `Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial`, fontWeight: 400, fontStyle: "normal" };
  }
  const f = font;
  return { fontFamily: f.family || f.fontFamily || `Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial`, fontWeight: f.weight ?? f.fontWeight ?? 400, fontStyle: f.style ?? f.fontStyle ?? "normal" };
}
function splitChars(str) {
  return Array.from(str);
}
function ZipText(props) {
  const { text = "Testimoinals", font, textColor = "#FFFFFF", letterSpacing = 0, timeAnimation = 4, offsetPx = 40, fitSize = 0.985, repeatOnVisible = false, width = "100%", height = 120, lastSymbolColor: lastSymbolColorProp, ...rest } = props;
  const lastSymbolColor = lastSymbolColorProp ?? textColor;
  const rootRef = React.useRef(null);
  const measureRef = React.useRef(null);
  const [fontPx, setFontPx] = React.useState(64);
  const [runId, setRunId] = React.useState(0);
  const [playedOnce, setPlayedOnce] = React.useState(false);
  const [ready, setReady] = React.useState(false);
  const [containerW, setContainerW] = React.useState(0);
  const isEditor = RenderTarget.current() === RenderTarget.canvas;
  const [show, setShow] = React.useState(isEditor);
  const [armed, setArmed] = React.useState(isEditor);
  const active = runId > 0;
  const chars = React.useMemo(() => splitChars(text), [text]);
  const fcss = React.useMemo(() => fontCSS(font), [font]);
  const ordMap = React.useMemo(() => {
    const map = new Array(chars.length).fill(-1);
    let k = 0;
    for (let i = 0; i < chars.length; i++) {
      if (!/\s/.test(chars[i])) map[i] = k++;
    }
    return map;
  }, [chars]);
  const nonSpaceCount = React.useMemo(() => ordMap.filter((v) => v >= 0).length, [ordMap]);
  const recomputeMetrics = React.useCallback(() => {
    const root = rootRef.current;
    const measure = measureRef.current;
    if (!root || !measure) return;
    measure.style.fontSize = `${REF_FONTSIZE}px`;
    measure.style.letterSpacing = `${letterSpacing}em`;
    void measure.offsetWidth;
    const natural = measure.scrollWidth || measure.offsetWidth;
    const cw = root.clientWidth;
    if (natural <= 0 || cw <= 0) return;
    const scale = cw / natural * fitSize;
    const computed = Math.max(1, REF_FONTSIZE * scale);
    setFontPx(computed);
    setContainerW(cw);
    setReady(true);
  }, [letterSpacing, fitSize]);
  React.useLayoutEffect(() => {
    setReady(false);
    recomputeMetrics();
    const ro = new ResizeObserver(() => recomputeMetrics());
    const node = rootRef.current;
    if (node) ro.observe(node);
    return () => ro.disconnect();
  }, [recomputeMetrics, text, fcss.fontFamily, fcss.fontWeight, fcss.fontStyle]);
  const inViewRef = React.useRef(false);
  const tryTrigger = React.useCallback(() => {
    if (isEditor || !ready) return;
    const el = rootRef.current;
    if (!el) return;
    const r = el.getBoundingClientRect();
    const inView = r.bottom > 0 && r.top < __unframerWindow.innerHeight;
    setShow(inView || isEditor);
    if (inView && !inViewRef.current) {
      setArmed(false);
      if (repeatOnVisible) {
        setRunId((id) => id + 1);
      } else if (!playedOnce) {
        setRunId((id) => id + 1);
        setPlayedOnce(true);
      }
      requestAnimationFrame(() => setArmed(true));
    }
    if (!inView && inViewRef.current) {
      setArmed(false);
      setShow(isEditor ? true : false);
    }
    inViewRef.current = inView;
  }, [isEditor, repeatOnVisible, playedOnce, ready]);
  React.useEffect(() => {
    if (repeatOnVisible) setPlayedOnce(false);
  }, [repeatOnVisible]);
  React.useEffect(() => {
    const el = rootRef.current;
    if (!el || isEditor) return;
    const io = new IntersectionObserver(
      () => requestAnimationFrame(tryTrigger),
      { root: null, threshold: [0, 0.15, 0.3, 0.6] }
      // inert thresholds reduce flicker
    );
    io.observe(el);
    if (ready) requestAnimationFrame(tryTrigger);
    return () => io.disconnect();
  }, [tryTrigger, isEditor, ready]);
  const perCharDur = Math.max(0.36, Math.min(1, timeAnimation * 0.33));
  const totalDelaySpan = Math.max(0, timeAnimation - perCharDur);
  const lineStartX = Math.round((containerW || 1e3) * 1.02);
  const rootStyle = { position: "relative", width, height, display: "grid", alignItems: "center", justifyItems: "stretch", background: "transparent", overflow: "hidden", contain: "layout paint style", visibility: isEditor || show ? "visible" : "hidden" };
  const lineStyleBase = { width: "100%", whiteSpace: "nowrap", color: textColor, ...fcss, fontSize: `${fontPx}px`, lineHeight: 1.05, letterSpacing: `${letterSpacing}em`, userSelect: "text", willChange: "transform, opacity", visibility: "hidden", ["--lineStartX"]: "200vw", transform: "translate3d(var(--lineStartX), 0, 0)" };
  const lineAnimStyle = active && !isEditor ? { animationName: LINE_KF, animationDuration: `${timeAnimation}s`, animationDelay: `0s`, animationTimingFunction: "cubic-bezier(0.22, 0.61, 0.36, 1)", animationFillMode: "both", animationPlayState: armed ? "running" : "paused", ["--lineStartX"]: `${lineStartX}px`, visibility: show && armed ? "visible" : "hidden" } : !active && !isEditor ? { visibility: "hidden" } : {
    // Editor: show static preview without animation
    visibility: "visible",
    transform: "translate3d(0, 0, 0)"
  };
  return /* @__PURE__ */ _jsxs("div", { ref: rootRef, style: rootStyle, ...rest, children: [/* @__PURE__ */ _jsx("style", { children: `
        @keyframes ${CHAR_KF} {
          from {
            opacity: 0;
            transform: translate3d(0, var(--offY, 0px), 0);
          }
          to {
            opacity: 1;
            transform: translate3d(0, 0, 0);
          }
        }
        @keyframes ${LINE_KF} {
          from { transform: translate3d(var(--lineStartX, 600px), 0, 0); }
          to   { transform: translate3d(0px, 0, 0); }
        }
      ` }), /* @__PURE__ */ _jsx("div", { ref: measureRef, style: { position: "fixed", visibility: "hidden", pointerEvents: "none", left: -99999, top: -99999, whiteSpace: "nowrap", ...fcss, fontSize: `${REF_FONTSIZE}px`, lineHeight: 1.05, letterSpacing: `${letterSpacing}em` }, children: text }), ready && (isEditor || show) && /* @__PURE__ */ _jsx("div", { style: { ...lineStyleBase, ...lineAnimStyle }, children: chars.map((ch, i) => {
    const isSpace = /\s/.test(ch);
    if (isSpace) return /* @__PURE__ */ _jsx("span", { children: ch }, `sp_${runId}_${i}`);
    const ord = ordMap[i];
    const delay = nonSpaceCount > 1 ? totalDelaySpan * ord / (nonSpaceCount - 1) : 0;
    const dy = ord % 2 === 0 ? -Math.abs(offsetPx) : Math.abs(offsetPx);
    const isLastSymbol = nonSpaceCount > 0 && ord === nonSpaceCount - 1;
    const style = active && !isEditor ? { display: "inline-block", opacity: 0, transform: "translate3d(0, var(--offY, 0px), 0)", animationName: CHAR_KF, animationDuration: `${perCharDur}s`, animationDelay: `${delay}s`, animationTimingFunction: "cubic-bezier(0.22, 0.61, 0.36, 1)", animationFillMode: "both", animationPlayState: armed ? "running" : "paused", backfaceVisibility: "hidden", willChange: "transform, opacity", ["--offY"]: `${dy}px`, ...isLastSymbol ? { color: lastSymbolColor } : null } : isEditor ? { display: "inline-block", opacity: 1, transform: "translate3d(0, 0, 0)", ["--offY"]: `${dy}px`, ...isLastSymbol ? { color: lastSymbolColor } : null } : {
      // Not yet active on the web â†’ keep hidden
      display: "inline-block",
      opacity: 0,
      transform: "translate3d(0, var(--offY, 0px), 0)",
      ["--offY"]: `${dy}px`,
      ...isLastSymbol ? { color: lastSymbolColor } : null
    };
    return /* @__PURE__ */ _jsx("span", { style, children: ch }, `ch_${runId}_${i}`);
  }) }, runId)] });
}
addPropertyControls(ZipText, { text: { type: ControlType.String, title: "Text", defaultValue: "Testimonials", displayTextArea: true }, font: { type: ControlType.Font, title: "Font", defaultValue: "Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, Arial" }, textColor: { type: ControlType.Color, title: "Text Color", defaultValue: "#FFFFFF" }, lastSymbolColor: { type: ControlType.Color, title: "Last Symbol Color", defaultValue: "#FFFFFF" }, letterSpacing: { type: ControlType.Number, title: "Letter Spacing (em)", min: -5, max: 5, step: 1e-3, defaultValue: 0, unit: "em", displayStepper: true }, timeAnimation: { type: ControlType.Number, title: "Time Animation", min: 0.3, max: 20, step: 0.05, defaultValue: 4, unit: "s", displayStepper: true }, offsetPx: { type: ControlType.Number, title: "Offset (px)", min: 0, max: 400, step: 1, defaultValue: 40, displayStepper: true }, fitSize: { type: ControlType.Number, title: "Fit Size", min: 0.75, max: 1.5, step: 1e-3, defaultValue: 0.985 }, repeatOnVisible: { type: ControlType.Boolean, title: "Repeat on Visible", defaultValue: false, enabledTitle: "On", disabledTitle: "Off" } });

export {
  ZipText
};
