// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 1bd92cedbbf431b3 "Sentinel AI", do not edit manually */
// /:https://framerusercontent.com/modules/fNfLf66xDJHwBCuXuBaz/QdDdiq0UBZG0Fk4NvaWz/BookFlip.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import * as React from "react";
import { addPropertyControls, ControlType } from "unframer";
function BookFlip(props) {
  const { images = [], pageWidth = 400, pageHeight = 650, radius = 14, perspective = 1300, maxRotDeg = 180, follow = 0.25, snapBias = 0.5, pxPerPage = 300, initialPeek = 0.12, tiltDeg = -3 } = props;
  const pairs = React.useMemo(() => {
    const out = [];
    for (let i = 0; i < images.length; i += 2) {
      const front = images[i];
      const back = images[i + 1] ?? images[i];
      if (front) out.push({ front, back });
    }
    return out;
  }, [images]);
  const [isLoading, setIsLoading] = React.useState(true);
  const stageRef = React.useRef(null);
  const bookRef = React.useRef(null);
  const pageRefs = React.useRef([]);
  const setPageRef = React.useCallback((index) => (el) => {
    pageRefs.current[index] = el;
  }, []);
  const cssVars = React.useMemo(() => ({ ["--w"]: `${pageWidth}px`, ["--h"]: `${pageHeight}px`, ["--radius"]: `${radius}px`, ["--persp"]: `${perspective}px`, ["--tilt"]: `${tiltDeg}deg` }), [pageWidth, pageHeight, radius, perspective, tiltDeg]);
  React.useEffect(() => {
    if (pairs.length === 0) {
      setIsLoading(false);
      return;
    }
    const jobs = [];
    for (const p of pairs) {
      for (const src of [p.front, p.back]) {
        const img = new Image();
        img.src = src;
        jobs.push(new Promise((r) => {
          img.onload = () => r();
          img.onerror = () => r();
        }));
      }
    }
    Promise.all(jobs).then(() => setIsLoading(false));
  }, [pairs]);
  React.useEffect(() => {
    if (isLoading) return;
    const stage = stageRef.current;
    if (!stage) return;
    let t = 0;
    let T = initialPeek;
    const N = pairs.length;
    const MAX = maxRotDeg * Math.PI / 180;
    let isDown = false;
    let lastX = 0;
    let lastTime = 0;
    let velocity = 0;
    const EPSZ = 0.1;
    const LEFT_EPSZ = 2;
    const SPINE_SHIFT = -0.75;
    const H = pageHeight;
    const clamp = (x, a, b) => x < a ? a : x > b ? b : x;
    const easeInOutCubic = (u) => u < 0.5 ? 4 * u * u * u : 1 - Math.pow(-2 * u + 2, 3) / 2;
    const onDown = (e) => {
      isDown = true;
      stage.classList.add("dragging");
      lastX = e.clientX;
      lastTime = performance.now();
      velocity = 0;
      stage.setPointerCapture(e.pointerId);
      e.preventDefault();
    };
    const onMove = (e) => {
      if (!isDown) return;
      const now = performance.now();
      const dx = e.clientX - lastX;
      lastX = e.clientX;
      const dt = now - lastTime || 16;
      lastTime = now;
      velocity = dx / dt;
      T = clamp(T - dx / pxPerPage, 0, N);
      e.preventDefault();
    };
    const onUp = (e) => {
      if (!isDown) return;
      isDown = false;
      stage.classList.remove("dragging");
      try {
        stage.releasePointerCapture(e.pointerId);
      } catch {
      }
      const base = Math.round(T);
      let snap = base;
      const FLICK_V_TH = 9;
      if (Math.abs(velocity) > FLICK_V_TH) snap = clamp(base + (velocity < 0 ? 1 : -1), 0, N);
      else {
        const frac = T - Math.floor(T);
        if (frac > 1 - snapBias) snap = Math.ceil(T);
        else if (frac < snapBias) snap = Math.floor(T);
      }
      T = clamp(snap, 0, N);
    };
    stage.addEventListener("pointerdown", onDown, { passive: false });
    stage.addEventListener("pointermove", onMove, { passive: false });
    stage.addEventListener("pointerup", onUp, { passive: true });
    stage.addEventListener("pointercancel", onUp, { passive: true });
    stage.addEventListener("lostpointercapture", onUp, { passive: true });
    let raf = 0;
    const loop = () => {
      t += (T - t) * follow;
      const lastIndex = N - 1;
      const opened = Math.min(Math.floor(t + 1e-6), lastIndex);
      const lastFully = t >= N - 1e-4;
      for (let i = 0; i < N; i++) {
        const el = pageRefs.current[i];
        if (!el) continue;
        const front = el.firstElementChild;
        const back = el.lastElementChild;
        const u = clamp(t - i, 0, 1);
        const ue = easeInOutCubic(u);
        const deg = -ue * MAX * 180 / Math.PI;
        const inLeftStack = i < opened || i === lastIndex && lastFully;
        let z = -EPSZ * i;
        if (inLeftStack) {
          const rank = i === lastIndex && lastFully ? 0 : Math.max(1, opened - i);
          z -= LEFT_EPSZ * rank;
        }
        el.style.transformOrigin = "left center";
        el.style.transform = `translate3d(${SPINE_SHIFT}px, ${-H / 2}px, ${z}px) rotateY(${deg}deg)`;
        const showBack = u >= 0.5;
        if (front) front.style.opacity = showBack ? "0" : "1";
        if (back) back.style.opacity = showBack ? "1" : "0";
        let zIndex;
        const isActive = i === opened && !lastFully;
        if (lastFully && i === lastIndex) zIndex = 4e4;
        else if (isActive) zIndex = 3e4;
        else if (inLeftStack) zIndex = 2e4 + i;
        else zIndex = 1e4 - i;
        el.style.zIndex = String(zIndex);
      }
      raf = requestAnimationFrame(loop);
    };
    raf = requestAnimationFrame(loop);
    return () => {
      cancelAnimationFrame(raf);
      stage.removeEventListener("pointerdown", onDown);
      stage.removeEventListener("pointermove", onMove);
      stage.removeEventListener("pointerup", onUp);
      stage.removeEventListener("pointercancel", onUp);
      stage.removeEventListener("lostpointercapture", onUp);
    };
  }, [pairs.length, pageHeight, maxRotDeg, follow, snapBias, pxPerPage, initialPeek, isLoading]);
  return /* @__PURE__ */ _jsxs("div", { className: "root", style: cssVars, children: [isLoading && /* @__PURE__ */ _jsx("div", { className: "preloader", children: /* @__PURE__ */ _jsx("div", { className: "loading-text", children: "Loading..." }) }), /* @__PURE__ */ _jsx("div", { ref: stageRef, className: "stage", style: { perspective: `${perspective}px`, WebkitPerspective: `${perspective}px`, perspectiveOrigin: "50% 66%", WebkitPerspectiveOrigin: "50% 66%", opacity: isLoading ? 0 : 1, transition: "opacity 0.3s ease-in" }, children: /* @__PURE__ */ _jsx("div", { ref: bookRef, className: "book", style: { height: `var(--h)`, transform: `rotate(${tiltDeg}deg)` }, children: pairs.map((p, i) => /* @__PURE__ */ _jsxs("figure", { className: "panel", ref: setPageRef(i), children: [/* @__PURE__ */ _jsx("div", { className: "face front", children: /* @__PURE__ */ _jsx("img", { src: p.front, alt: "", decoding: "async", loading: "lazy", draggable: false }) }), /* @__PURE__ */ _jsx("div", { className: "face back", children: /* @__PURE__ */ _jsx("img", { src: p.back, alt: "", decoding: "async", loading: "lazy", draggable: false }) })] }, i)) }) }), /* @__PURE__ */ _jsx("style", { children: `
    .root{position:relative;width:100%;height:100%;background:transparent;overflow:visible;-webkit-tap-highlight-color:transparent}
    .preloader{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:transparent;z-index:50000}
    .loading-text{font-size:1.2em;font-weight:500;color:white;letter-spacing:0.5px}

    .stage{position:absolute;inset:0;display:grid;place-items:center;user-select:none;touch-action:none;cursor:grab}
    .stage.dragging{cursor:grabbing}

    .book{
        position:relative;width:1px;
        transform-style:preserve-3d;
        -webkit-transform-style:preserve-3d;        /* \u0446\u0435\u043F\u043E\u0447\u043A\u0430 3D \u0434\u043B\u044F WebKit */
    }

    .panel{
        position:absolute;top:50%;left:50%;
        width:var(--w);height:var(--h);
        transform-style:preserve-3d;
        -webkit-transform-style:preserve-3d;
        border-radius:var(--radius);
        overflow:hidden;
        will-change:transform;
    }

    .face{position:absolute;inset:0;border-radius:var(--radius);pointer-events:none}
    .face img{display:block;width:100%;height:100%;object-fit:cover;-webkit-user-drag:none;user-select:none;pointer-events:none}
    .back{transform:rotateY(180deg) translateZ(0.02px)}

    /* --- Mobile fix: \u0440\u0435\u0430\u043B\u044C\u043D\u0430\u044F \u043F\u0435\u0440\u0441\u043F\u0435\u043A\u0442\u0438\u0432\u0430 \u0447\u0435\u0440\u0435\u0437 transform \u043D\u0430 \u043A\u043D\u0438\u0433\u0435 --- */
    @media (max-width:809px){
      /* \u0433\u0430\u0441\u0438\u043C \u043F\u0435\u0440\u0441\u043F\u0435\u043A\u0442\u0438\u0432\u0443 \u0440\u043E\u0434\u0438\u0442\u0435\u043B\u044F (inline) \u0438 \u0437\u0430\u0434\u0430\u0451\u043C \u0435\u0451 \u043D\u0430 \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0435-\u043A\u043D\u0438\u0433\u0435 */
      .stage{
        perspective:none !important;
        -webkit-perspective:none !important;
      }
      .book{
        /* \u043F\u0435\u0440\u0435\u043E\u043F\u0440\u0435\u0434\u0435\u043B\u044F\u0435\u043C \u0438\u043D\u043B\u0430\u0439\u043D-rotate: \u0434\u043E\u0431\u0430\u0432\u043B\u044F\u0435\u043C perspective(...) \u043F\u0435\u0440\u0435\u0434 rotate(...) */
        transform: perspective(var(--persp)) rotate(var(--tilt)) !important;
        -webkit-transform: perspective(var(--persp)) rotate(var(--tilt)) !important;
        transform-origin: 50% 66% !important;
        -webkit-transform-style:preserve-3d;
      }
    }
` })] });
}
addPropertyControls(BookFlip, { images: { type: ControlType.Array, title: "Images", control: { type: ControlType.Image }, defaultValue: [] }, pageWidth: { type: ControlType.Number, title: "Page W", min: 120, max: 1200, unit: "px", defaultValue: 400 }, pageHeight: { type: ControlType.Number, title: "Page H", min: 160, max: 1600, unit: "px", defaultValue: 650 }, radius: { type: ControlType.Number, title: "Radius", min: 0, max: 48, unit: "px", defaultValue: 14 }, perspective: { type: ControlType.Number, title: "Perspective", min: 300, max: 3e3, unit: "px", defaultValue: 1300 }, maxRotDeg: { type: ControlType.Number, title: "Max Rot", min: 60, max: 200, unit: "\xB0", defaultValue: 180 }, follow: { type: ControlType.Number, title: "Follow", min: 0.05, max: 0.6, step: 0.01, defaultValue: 0.25 }, snapBias: { type: ControlType.Number, title: "Snap Bias", min: 0.1, max: 0.9, step: 0.05, defaultValue: 0.5 }, pxPerPage: { type: ControlType.Number, title: "Drag PX/Page", min: 80, max: 800, step: 10, defaultValue: 300 }, initialPeek: { type: ControlType.Number, title: "Initial Peek", min: 0, max: 0.5, step: 0.01, defaultValue: 0.12 }, tiltDeg: { type: ControlType.Number, title: "Tilt", min: -15, max: 15, step: 0.1, unit: "\xB0", defaultValue: -3 } });

export {
  BookFlip
};
