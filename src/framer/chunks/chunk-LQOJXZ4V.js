// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 1bd92cedbbf431b3 "Sentinel AI", do not edit manually */
// /:https://framerusercontent.com/modules/2ija6T2Cmy0bt2ak4tGK/wND0bX7TKUtmqt01nmpY/Starsfield.js
import { jsx as _jsx } from "react/jsx-runtime";
import * as React from "react";
import { addPropertyControls, ControlType, RenderTarget } from "unframer";
var __unframerWindow = typeof window !== "undefined" ? window : void 0;
var Z_NEAR = 0.12;
var Z_FAR = 0.98;
var OFFSCREEN_MARGIN = 40;
function saturate(t) {
  return t < 0 ? 0 : t > 1 ? 1 : t;
}
function smooth01(t) {
  return t * t * (3 - 2 * t);
}
function parseColor(input) {
  const c = (input || "#000000").trim().toLowerCase();
  if (c[0] === "#") {
    const h = c.slice(1);
    if (h.length === 3 || h.length === 4) {
      const r = parseInt(h[0] + h[0], 16);
      const g = parseInt(h[1] + h[1], 16);
      const b = parseInt(h[2] + h[2], 16);
      const a = h.length === 4 ? parseInt(h[3] + h[3], 16) / 255 : 1;
      return { r, g, b, a };
    }
    if (h.length === 6 || h.length === 8) {
      const r = parseInt(h.slice(0, 2), 16);
      const g = parseInt(h.slice(2, 4), 16);
      const b = parseInt(h.slice(4, 6), 16);
      const a = h.length === 8 ? parseInt(h.slice(6, 8), 16) / 255 : 1;
      return { r, g, b, a };
    }
  }
  const m = c.match(/rgba?\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)(?:\s*,\s*([\d.]+)\s*)?\)/);
  if (m) {
    const r = Math.max(0, Math.min(255, Number(m[1])));
    const g = Math.max(0, Math.min(255, Number(m[2])));
    const b = Math.max(0, Math.min(255, Number(m[3])));
    const a = m[4] !== void 0 ? Math.max(0, Math.min(1, Number(m[4]))) : 1;
    return { r, g, b, a };
  }
  return { r: 0, g: 0, b: 0, a: 1 };
}
function isEditorTarget() {
  try {
    return RenderTarget.current() !== RenderTarget.preview;
  } catch {
    return false;
  }
}
function Starsfield(props) {
  const { starCount = 300, speed = 0.2, spread = 2, focal = 0.6, twinkle = 0.3, trail = 0.3, starSize = 0.5, bgColor = "#000000", starColor = "#FFFFFF", fadeInRange = 0.3, reverseFly = false, stopMotionInEditor = false } = props;
  const canvasRef = React.useRef(null);
  const starsRef = React.useRef([]);
  const rafRef = React.useRef(null);
  const lastTimeRef = React.useRef(performance.now());
  const frameCountRef = React.useRef(0);
  const pausedRef = React.useRef(false);
  const settingsRef = React.useRef({ starCount, speed, spread, focal, twinkle, trail, starSize, bgColor, starColor, fadeInRange, reverseFly, stopMotionInEditor });
  settingsRef.current = { starCount, speed, spread, focal, twinkle, trail, starSize, bgColor, starColor, fadeInRange, reverseFly, stopMotionInEditor };
  const colorCacheRef = React.useRef({ bg: parseColor(bgColor), star: parseColor(starColor) });
  const resize = React.useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const parent = canvas.parentElement;
    if (!parent) return;
    const w = Math.max(1, parent.clientWidth);
    const h = Math.max(1, parent.clientHeight);
    const dpr = Math.min(__unframerWindow.devicePixelRatio || 1, 2);
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    const ctx = canvas.getContext("2d");
    if (ctx) {
      ctx.resetTransform?.();
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
  }, []);
  function respawnStar(s, w, h, f, reversed, spread2, starSize2, zOverride) {
    const z = zOverride ?? (reversed ? Z_NEAR : Z_FAR);
    const halfW = w / 2;
    const halfH = h / 2;
    const sx = (Math.random() * 2 - 1) * (halfW * spread2 + OFFSCREEN_MARGIN);
    const sy = (Math.random() * 2 - 1) * (halfH * spread2 + OFFSCREEN_MARGIN);
    s.z = z;
    s.x = sx * z / f;
    s.y = sy * z / f;
    s.px = null;
    s.py = null;
    s.phase = Math.random() * Math.PI * 2;
    s.twinkle = 0.5 + Math.random() * 1.5;
    s.size = starSize2 * (0.6 + Math.random() * 0.8);
  }
  const initStars = React.useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const w = Math.max(1, canvas.clientWidth);
    const h = Math.max(1, canvas.clientHeight);
    const { focal: focal2, reverseFly: reverseFly2, spread: spread2, starSize: starSize2, starCount: starCount2 } = settingsRef.current;
    const f = Math.min(w, h) * focal2;
    const arr = new Array(starCount2).fill(0).map(() => {
      const s = { x: 0, y: 0, z: 0.5, px: null, py: null, phase: 0, twinkle: 1, size: starSize2 };
      const z = Z_NEAR + Math.random() * (Z_FAR - Z_NEAR);
      respawnStar(s, w, h, f, reverseFly2, spread2, starSize2, z);
      return s;
    });
    starsRef.current = arr;
  }, []);
  const drawFrame = React.useCallback((ctx, canvas, now, dt) => {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const cx = w / 2;
    const cy = h / 2;
    const { speed: speed2, spread: spread2, focal: focal2, twinkle: twinkle2, trail: trail2, starSize: starSize2, fadeInRange: fadeInRange2, reverseFly: reverseFly2 } = settingsRef.current;
    const { bg, star } = colorCacheRef.current;
    ctx.globalCompositeOperation = "source-over";
    if (trail2 > 0.01) {
      const clearA = (1 - Math.min(0.98, Math.max(0, trail2))) * bg.a;
      ctx.fillStyle = `rgba(${bg.r},${bg.g},${bg.b},${clearA})`;
      ctx.fillRect(0, 0, w, h);
    } else {
      ctx.clearRect(0, 0, w, h);
    }
    const f = Math.min(w, h) * focal2;
    const invFocal = 1 / f;
    const speedFactor = dt * speed2 * 0.7 * (reverseFly2 ? 1 : -1);
    const twinkleSpeed = now * 15e-4;
    const range = Math.max(0.05, Math.min(fadeInRange2, Z_FAR - Z_NEAR));
    const invRange = 1 / range;
    const starPaths = [];
    const trailSegments = [];
    const rgbaCache = /* @__PURE__ */ new Map();
    const getCachedColor = (alpha) => {
      const key = Math.round(alpha * 1e3);
      if (!rgbaCache.has(key)) {
        rgbaCache.set(key, `rgba(${star.r},${star.g},${star.b},${alpha})`);
      }
      return rgbaCache.get(key);
    };
    const stars = starsRef.current;
    for (let i = 0; i < stars.length; i++) {
      const s = stars[i];
      s.z += speedFactor;
      if (!reverseFly2 && s.z <= Z_NEAR || reverseFly2 && s.z >= Z_FAR) {
        respawnStar(s, w, h, f, reverseFly2, spread2, starSize2);
        continue;
      }
      const invz = 1 / s.z;
      const x2d = s.x * f * invz + cx;
      const y2d = s.y * f * invz + cy;
      if (x2d < -OFFSCREEN_MARGIN || x2d > w + OFFSCREEN_MARGIN || y2d < -OFFSCREEN_MARGIN || y2d > h + OFFSCREEN_MARGIN) {
        respawnStar(s, w, h, f, reverseFly2, spread2, starSize2);
        continue;
      }
      const twk = Math.max(0, Math.min(1, 0.65 + twinkle2 * 0.35 * Math.sin(s.phase + twinkleSpeed * s.twinkle)));
      const size = Math.max(0.3, s.size * invz * 0.9);
      const baseAlpha = Math.min(1, (0.15 + twk * 0.9) * star.a);
      const tRaw = reverseFly2 ? (s.z - Z_NEAR) * invRange : (Z_FAR - s.z) * invRange;
      const appear = smooth01(saturate(tRaw));
      const alpha = baseAlpha * appear;
      if (size < 0.5 || alpha < 0.01) {
        s.px = x2d;
        s.py = y2d;
        continue;
      }
      if (s.px !== null && s.py !== null) {
        trailSegments.push({ x1: s.px, y1: s.py, x2: x2d, y2: y2d, alpha: alpha * 0.3, width: Math.min(3, size) });
      }
      starPaths.push({ x: x2d, y: y2d, size: size * 0.5, alpha });
      s.px = x2d;
      s.py = y2d;
    }
    ctx.globalCompositeOperation = "lighter";
    ctx.lineCap = "round";
    for (let i = 0; i < trailSegments.length; i++) {
      const seg = trailSegments[i];
      ctx.lineWidth = seg.width;
      ctx.strokeStyle = getCachedColor(seg.alpha);
      ctx.beginPath();
      ctx.moveTo(seg.x1, seg.y1);
      ctx.lineTo(seg.x2, seg.y2);
      ctx.stroke();
    }
    for (let i = 0; i < starPaths.length; i++) {
      const st = starPaths[i];
      ctx.fillStyle = getCachedColor(st.alpha);
      ctx.beginPath();
      ctx.arc(st.x, st.y, st.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }, []);
  React.useEffect(() => {
    resize();
    initStars();
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const editorPaused = isEditorTarget() && settingsRef.current.stopMotionInEditor;
    if (editorPaused) {
      pausedRef.current = true;
      drawFrame(ctx, canvas, 0, 0);
    } else {
      pausedRef.current = false;
      const loop = () => {
        const nowEditorPaused = isEditorTarget() && settingsRef.current.stopMotionInEditor;
        if (nowEditorPaused) {
          pausedRef.current = true;
          drawFrame(ctx, canvas, 0, 0);
          rafRef.current = null;
          return;
        }
        const now = performance.now();
        const dt = Math.min(0.05, (now - lastTimeRef.current) / 1e3);
        lastTimeRef.current = now;
        frameCountRef.current++;
        if (frameCountRef.current % 600 === 0) {
        }
        drawFrame(ctx, canvas, now, dt);
        rafRef.current = requestAnimationFrame(loop);
      };
      rafRef.current = requestAnimationFrame(loop);
    }
    const onResize = () => {
      resize();
      initStars();
      if (pausedRef.current) {
        drawFrame(ctx, canvas, 0, 0);
      }
    };
    __unframerWindow.addEventListener("resize", onResize);
    return () => {
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      rafRef.current = null;
      __unframerWindow.removeEventListener("resize", onResize);
    };
  }, [initStars, resize, drawFrame]);
  React.useEffect(() => {
    initStars();
    if (isEditorTarget() && stopMotionInEditor) {
      const canvas = canvasRef.current;
      const ctx = canvas?.getContext("2d");
      if (canvas && ctx) drawFrame(ctx, canvas, 0, 0);
    }
  }, [starCount, reverseFly, spread, focal, initStars, stopMotionInEditor, drawFrame]);
  React.useEffect(() => {
    colorCacheRef.current = { bg: parseColor(bgColor), star: parseColor(starColor) };
    if (isEditorTarget() && stopMotionInEditor) {
      const canvas = canvasRef.current;
      const ctx = canvas?.getContext("2d");
      if (canvas && ctx) drawFrame(ctx, canvas, 0, 0);
    }
  }, [bgColor, starColor, stopMotionInEditor, drawFrame]);
  return /* @__PURE__ */ _jsx("div", { style: { width: "100%", height: "100%", background: bgColor, overflow: "hidden" }, children: /* @__PURE__ */ _jsx("canvas", { ref: canvasRef }) });
}
addPropertyControls(Starsfield, { starCount: { type: ControlType.Number, title: "Stars", min: 50, max: 4e3, step: 50, defaultValue: 300 }, speed: { type: ControlType.Number, title: "Speed", min: 0, max: 2, step: 0.01, defaultValue: 0.2 }, spread: { type: ControlType.Number, title: "Spread", min: 1, max: 5, step: 0.1, defaultValue: 2 }, focal: { type: ControlType.Number, title: "Focal", min: 0.4, max: 1.6, step: 0.05, defaultValue: 0.6 }, twinkle: { type: ControlType.Number, title: "Twinkle", min: 0, max: 1, step: 0.01, defaultValue: 0.3 }, trail: { type: ControlType.Number, title: "Trail", min: 0, max: 0.98, step: 0.01, defaultValue: 0.3 }, starSize: { type: ControlType.Number, title: "Size", min: 0.3, max: 3, step: 0.1, defaultValue: 0.5 }, fadeInRange: { type: ControlType.Number, title: "Fade-In Range", min: 0.05, max: 1, step: 0.01, defaultValue: 0.3 }, reverseFly: { type: ControlType.Boolean, title: "Reverse Fly", defaultValue: false }, stopMotionInEditor: { type: ControlType.Boolean, title: "Stop Motion in Editor", defaultValue: false }, bgColor: { type: ControlType.Color, title: "Background", defaultValue: "#000000" }, starColor: { type: ControlType.Color, title: "Stars", defaultValue: "#FFFFFF" } });
Starsfield.defaultProps = { height: 800, width: 1e3 };

export {
  Starsfield
};
